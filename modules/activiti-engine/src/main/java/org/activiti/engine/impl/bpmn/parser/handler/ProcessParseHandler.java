/* Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.activiti.engine.impl.bpmn.parser.handler;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.activiti.bpmn.model.BaseElement;
import org.activiti.bpmn.model.EventListener;
import org.activiti.bpmn.model.ImplementationType;
import org.activiti.bpmn.model.Process;
import org.activiti.engine.delegate.event.ActivitiEventType;
import org.activiti.engine.impl.bpmn.data.IOSpecification;
import org.activiti.engine.impl.bpmn.parser.BpmnParse;
import org.activiti.engine.impl.el.ExpressionManager;
import org.activiti.engine.impl.persistence.entity.ProcessDefinitionEntity;
import org.activiti.engine.impl.task.TaskDefinition;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * @author Joram Barrez
 *  因为流程文档中大部分元素是process元素的子元素
 *  所以这里以process元素的属性承载类 Process为入口
 *
 */
public class ProcessParseHandler extends AbstractBpmnParseHandler<Process> {
  
  private static final Logger LOGGER = LoggerFactory.getLogger(ProcessParseHandler.class);
  
  public static final String PROPERTYNAME_DOCUMENTATION = "documentation";
  
  public Class< ? extends BaseElement> getHandledType() {
    return Process.class;
  }
  
  protected void executeParse(BpmnParse bpmnParse, Process process) {
      // 因为对 不会执行的 process 对象进行解析时没有意义的
    if (process.isExecutable() == false) {
      LOGGER.info("Ignoring non-executable process with id='" + process.getId() + "'. Set the attribute isExecutable=\"true\" to deploy this process.");
    } else {
        //如果为true, 开始解析   解析完毕之后 将 返回值 添加到 processDefinitions集合中
      bpmnParse.getProcessDefinitions().add(transformProcess(bpmnParse, process));
    }
  }
  /*
    开始解析 Process
  * */
  protected ProcessDefinitionEntity transformProcess(BpmnParse bpmnParse, Process process) {
      //流程定义实体属性承载类
    ProcessDefinitionEntity currentProcessDefinition = new ProcessDefinitionEntity();
    //设置到bpmnParse 对象中
    bpmnParse.setCurrentProcessDefinition(currentProcessDefinition);

    /*
     * Mapping object model - bpmn xml: processDefinition.id -> generated by
     * activiti engine processDefinition.key -> bpmn id (required)
     * processDefinition.name -> bpmn name (optional)
     */
    currentProcessDefinition.setKey(process.getId());
    currentProcessDefinition.setName(process.getName());
    //targetNameSapce 作为流程定义分类使用
    currentProcessDefinition.setCategory(bpmnParse.getBpmnModel().getTargetNamespace());
    //文档信息
    currentProcessDefinition.setDescription(process.getDocumentation()); 
    currentProcessDefinition.setProperty(PROPERTYNAME_DOCUMENTATION, process.getDocumentation()); // Kept for backwards compatibility. See ACT-1020
      // 暂时还没有开始解析任务节点, 先实例化HashMap ,防止该属性值为空 ,程序报错
    currentProcessDefinition.setTaskDefinitions(new HashMap<String, TaskDefinition>());
    //设置部署id
    currentProcessDefinition.setDeploymentId(bpmnParse.getDeployment().getId());
    //创建执行监听器
    createExecutionListenersOnScope(bpmnParse, process.getExecutionListeners(), currentProcessDefinition);
    //创建事件监听器  只有process 元素才可以配置全局事件监听器,其他元素不可以定义事件监听器
    createEventListeners(bpmnParse, process.getEventListeners(), currentProcessDefinition);
    //获取表达式管理器
    ExpressionManager expressionManager = bpmnParse.getExpressionManager();
    //循环遍历Process中的启动人
    for (String candidateUser : process.getCandidateStarterUsers()) {
      currentProcessDefinition.addCandidateStarterUserIdExpression(expressionManager.createExpression(candidateUser));
    }
    //遍历Porcess 启动候选人组
    for (String candidateGroup : process.getCandidateStarterGroups()) {
      currentProcessDefinition.addCandidateStarterGroupIdExpression(expressionManager.createExpression(candidateGroup));
    }

    if (LOGGER.isDebugEnabled()) {
      LOGGER.debug("Parsing process {}", currentProcessDefinition.getKey());
    }
    /*
    设置到bpmnParse 对象中
    BpmnParse 作为解析process对象的入口  ,所哟逇对象解析器都需要使用该类
    该类承载process对象解析入口的同时 也承载了公共属性的存取

    必须要牢记一点,
    解析process对象时 ,首先将 currentProcessDefinition 对象
    设置到bpmnParse对象的 currentScopeStack 中  (内部 使用LinkedList作为栈使用)
    然后再解析process 子元素对象,
    子元素对象解析的时候 可以直接从bpmnParse 对象的 currentScopeStack 属性中 获取ProcessDefinitionEntity对象
    所有的子元素解析完毕
    执行
        下面的     bpmnParse.removeCurrentScope();  移除  currentScopeStack 集合中的元素
     */
    bpmnParse.setCurrentScope(currentProcessDefinition);
    /*
    开始解析该流程下的所有元素对象
    也就是解析刘成霞 所有元素的属性承载类实例对象
    流程中所有的子元素对象信息 都可以通过 processgetFlowElements () 进行获取
     */
    bpmnParse.processFlowElements(process.getFlowElements());
    //解析 createAssocation
    processArtifacts(bpmnParse, process.getArtifacts(), currentProcessDefinition);
    
    // parse out any data objects from the template in order to set up the necessary process variables
      //解析DataObject 对象并作为流程实例的变量使用
    Map<String, Object> variables = processDataObjects(bpmnParse, process.getDataObjects(), currentProcessDefinition);
    //获取变量信息
    if (null != currentProcessDefinition.getVariables()) {
      currentProcessDefinition.getVariables().putAll(variables);
    } else {
        //设置变量值
      currentProcessDefinition.setVariables(variables);
    }

    bpmnParse.removeCurrentScope();

    //webService的 输入 输出 参数进行 相互转换
    if (process.getIoSpecification() != null) {
        //获取IOSpecification 并设置到  currentProcessDefinition 对象中
      IOSpecification ioSpecification = createIOSpecification(bpmnParse, process.getIoSpecification());
      currentProcessDefinition.setIoSpecification(ioSpecification);
    }
    return currentProcessDefinition;
  }

	protected void createEventListeners(BpmnParse bpmnParse, List<EventListener> eventListeners,
      ProcessDefinitionEntity currentProcessDefinition) {
		
		if(eventListeners != null && !eventListeners.isEmpty()) {
			for(EventListener eventListener : eventListeners) {
				// Extract specific event-types (if any)
				ActivitiEventType[] types = ActivitiEventType.getTypesFromString(eventListener.getEvents());
				
				if(ImplementationType.IMPLEMENTATION_TYPE_CLASS.equals(eventListener.getImplementationType())) {
					currentProcessDefinition.getEventSupport().addEventListener(
							bpmnParse.getListenerFactory().createClassDelegateEventListener(eventListener),types);
				} else if(ImplementationType.IMPLEMENTATION_TYPE_DELEGATEEXPRESSION.equals(eventListener.getImplementationType())) {
					currentProcessDefinition.getEventSupport().addEventListener(
							bpmnParse.getListenerFactory().createDelegateExpressionEventListener(eventListener), types);
				} else if(ImplementationType.IMPLEMENTATION_TYPE_THROW_SIGNAL_EVENT.equals(eventListener.getImplementationType())
						|| ImplementationType.IMPLEMENTATION_TYPE_THROW_GLOBAL_SIGNAL_EVENT.equals(eventListener.getImplementationType())
						|| ImplementationType.IMPLEMENTATION_TYPE_THROW_MESSAGE_EVENT.equals(eventListener.getImplementationType())
						|| ImplementationType.IMPLEMENTATION_TYPE_THROW_ERROR_EVENT.equals(eventListener.getImplementationType())){
					currentProcessDefinition.getEventSupport().addEventListener(
							bpmnParse.getListenerFactory().createEventThrowingEventListener(eventListener), types);
				} else {
					LOGGER.warn("Unsupported implementation type for EventLIstener: " + eventListener.getImplementationType() 
							+ " for element " + bpmnParse.getCurrentFlowElement().getId());
				}
			}
		}
	  
  }

}
