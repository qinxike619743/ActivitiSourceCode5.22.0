门面模式
ProcessEngineImpl 对象的属性值 均从  ProcessEngineConfiguration 中进行获取 这是典型的门面模式,
为客户端的使用提供遍历, 无需关心 ProcessEngineConfiguration内部实现机制


开闭原则:
    如何实现流程文档的解析工作,首先每个元素都需要定义公共属性, 例如id name 等 可以把类似id name等
    公共属性的解析封装为一个通用的解析(),这样程序解析流程文档元素时,只需要调用该() 就可以完成公共属性的解析工作
    流程文档中还有一些元素的属性信息是容易变化的,为什么容易变化?? 因为Activiti版本升级可能会对部分元素添加
    新特性, 此时就需要对扩展元素对应的属性承载类添加一个新的属性定义 ,更致命的问题是
    添加新的属性就需要修改该元素的解析代码, 为了应对类似这样的变化,Activiti为每一个元素包括子元素
    定义了一个对应的元素解析器, 从俄日使得每一个元素解析器只负责一个元素的解析工作,
    这样的好处就是使得元素 和元素解析器一一对应, 分离抽取元素解析器的职责,进而让每个元素解析器之间
    尽量相互独立运行,
    当任意一个元素解析器的逻辑需要修改时不会级联修改其他的元素解析器,  这样流程文档自上而下解析时
    只需要根据元素名称查找元素对应的解析器进行处理即可

    为了遵守开闭原则,程序在设计之初就需要对系统进行抽象,提取更加直观一点就是面向接口编程,抽象化是
    开闭原则的基石,具体的实现思路是可以在系统中定义一个相对稳定的抽象层或者定义一个通用的模板方法
    将不同的实现行为移动到具体的实现层中完成,这样扩展类行为变化的时候,只需要修改具体的实现层代码即可
    而无需对抽象层过多修改,附带的好处就是类和类之间相互独立, 职责更加明确,不会出现类之间相互污染的情况







StreamSource 接口定义了getInputStream() 并且提供了一系列访问不同资源的实现类
因为 BPMNXMLConverter 类中的convertToBpmnModel() 需要 InputStreamProvider  典型的策略模式



事件转发器用的是 		观察者模式
			定义对象之间 一对一 或者一对多的依赖关系 ,
			当一个对象的状态发生变化时, 所有依赖于它的对象都会得到通知并自动更新
			ActivitiEventSupport 就是 目标对象
			该对象中定义了 观察者对象 ActivitiEventListener  的添加和 删除操作 以及通知 观察者的() dispatchEvent

任务代理类
首先从 Context类中 取出 ProcessEngineConfigurationImpl 对象
    然后获取 delegateInterceptor对象
    最后根据   ProcessEngineConfigurationImpl 对象以及 执行监听器对象实例化 ExecutionListenerInvocation类
    既然已经获取到监听器实例对象, 为何不直接触发 监听器中的notify() ???
      因为Activiti 在触发用户配置监听器中 的notify() 之前, 做了一层全局功能架构
      也即使用代理模式 对监听器的访问进行控制

Activiti 将客户端所有的请求操作 组装为 一个个命令类
        首先说明  不可能在一个()中完成非常复杂的逻辑, 目的是为了使() 尽可能单一和复用,也节省后期维护成本
        一个真正实现功能的() 代码量 其实是很少的  一般都是从全局角度做一些统筹工作


Activiti 职责链模式
    命令拦截器就是  被构造成链

        链 是 一系列相同类型的集合
        链中的任何节点可以灵活拆分和组装


    PVM 流程运转的原理 也是 职责链模式


工厂模式
    行为类 就是 工厂模式
        Activiti 将所有活动行为类的创建工作交给活动行为工厂类完成


































































