开始编译源码:
    git clone https://github.com/Activiti/Activiti.git

从码云下载 Activiti.5.22源码
https://gitee.com/hirsi-he/Activiti-activiti-5.22.0?_from=gitee_search

给自己的建议:
    下载的别人东西,对自己有用处,不打赏就算了(有的没有打赏方式),但是一定要给Star,
    毕竟别人的东西对你有帮助,
    因为臭名昭著的FastJSON居然20Kstar, 而 mybatis才 10几K
    我想这8000程序员 一定学过mybatis, 却不给mybatis star 啧啧啧
    怪不到成为不了强者 ...... 活该 ......



  Activiti源码  目录如下:
        1)distro 使用Ant 工具下载文档资料以及将Activiti项目打包
        2)README.md 记录Activiti团队的JIRA 和QA地址
        3)eclipse Activiti使用的Eclipse模板文件
        4)modules 该文件夹下存储了Activiti项目所有模块的Java源文件
        5)qa 一些通用的流程配置文件样例
        6) scripts: Linux平台下的一些启动脚本文件
        7)userguide 用户操作手册 需要使用 Asciidoctor 工具生成
        8)pom.xml 所有Maven工程的parent, Activiti工程依赖的第三方程序包都定义在该文件中

开始编译 mvn install   用IDEA   跳过 test模块
mvn install -Dmaven.test.skuo =true

以Activiti-engine 的源码工程进行相关说明
    src/main/java 用于存放项目的核心实现逻辑代码
    src/main/resources 用于存储配置文件
    src/test/java 对核心代码进行单元测试
    src/test/resources 存储对核心代码进行单元测试时需要使用的配置文件


Activiti源码下载好之后 ,可以查看 modules\activiti-engine 模块中的 src/main/resources文件夹,
该文件夹中存储了流程引擎操作DB 需要的DDL脚本

create 创建 数据库,表视图 ,索引的脚本, 形如activiti.db2.create.engine.sql 其中 db2 代表操作的数据库类型
drop  删除DB 视图,索引的脚本, 形如:activiti,db2.drop.engine.sql
upgrade 升级DB 视图,索引的脚本, 形如  activiti,db2.upgradestep.53.to.54. engine.sql
        其中53对应引擎的版本5.13 54对应引擎需要升级到的版本 5.14
mapping :
        由于Activiti底层使用MyBAtis 操作DB  因此该文件下对应MyBatis框架需要的所有的映射文件


以activiti.db2.create.history.sql 脚本为例讲解

activiti  工作流引擎的标识
db2  数据库厂商标识 MYSQL H2 Oracle PostgreSQL
create : 创建数据库表的操作 对应有 drop upgradestep 标识符号, 操作时选择对应的即可
engine 脚本类型 分为以下三种
    engine 主要用于创建核心表  例如ACT_RU* 表等
    history 历史表 ACT_HI*
    identity 用户表  ACT_ID * (扩展表时可以不使用该脚本)

引擎为何需要对以上三个脚本文件分别定义??? 很简单, 因为核心表(engine)是必须要使用的
    而历史表 (history) 用户表(identity) 是选用的 ,所以需要区分



关于Activiti的Eclipse 流程设计器(Eclipse中  叫做 Activiti Designer)
    在5.8版本之前流程设计文件的后缀为 .activiti
    比如流程文档名称为my.activiti    则保存该文件之后会自动生成my.bpmn20.xml
    5.9之后 Activiti废弃了这一做法, 流程文档的后缀修改为.bpmn
    问题来了,如何兼容这两个版本???
       直接将my.bpmn20.xml文件名称修改为bpmn  然后将my.activiti 文件删除即可
       因为这两个文件的内容都是相同的,只是文件的后缀不同而已, 这种()只适用于项目中流程比较少的情况
       如果项目有成千上万个呢? 上述() 显然不适用, 到时候我们可以自定义一个部署器 用来兼容老版本即可     让activiti后缀也可以部署

/////////////////////////  第二章  探险流程引擎 ///////////////////////////////////////
流程引擎为开发人员提供了一系列扩展带你, 这些扩展点都可以通过流程引擎配置类进行操作
开发人员可以通过流程引擎配置类构造  流程引擎对象,
从而划清了 配置类 和流程引擎类 的使用边界,  也使得两个类的职责更加单一,

流程配置文件:
    普通配置, 也即 Activiti配置风格,通常情况下使用该方式的文件名称为 activiti.cfg.xml
    Spring配置, 也即Spring配置风格,通常情况下, 使用该方式的文件名称为 activiti-context.xml

这两个风格的配置方式 基本一致, 因为两者本质上都是Spring配置方式 ,
只不过配置类的实现类 不一样, Spring整合 用的类 是 SpringProcessEngineConfiguration


关于getDefaultProcessEngine 实例化流程引擎的过程  但是存在两个缺陷
activiti.cfg.xml 或者activiti-context.xml 文件必须位于项目的classpath根目录中 否则加载不到
2) 默认情况下 activiti.cfg.xml 文件中流程引擎配置类的bean的id值 必须是processEngineConfiguration

问题?
    配置文件的路径可以灵活变动吗?
    名称可以修改吗?
    bean的id值 可以是任意值吗?

///////////////////////////////////////////////////////////////////////////////////////////


//////////////////////////////////第3章  流程资源部署 //////////////////////////////////////
在使用Activiti的时候,通常情况之下需要根据业务需求绘制流程文档  然后将流程文档进行部署 ,从而进行后续的
一系列操作,部署资源无疑至关重要,如何合理的使用引擎提供的部署资源功能 也是前期设计的重中之重 该过程
可以检查定义的流程资源是否合理,通用以及校验流程资源格式是否准确等,从而对 流程资源进行把关,规避一些不可预知的风险点

流程资源包含如下:
1)流程文档: 流程文档的扩展名一般为bpmn20.xml 或者bpmn
2) 图片 : 根据流程文档内容生成的图片,扩展名为png
3) Drools规则文件, 通常情况下 扩展名为drl
4) Form表单文件 , 通常情况下 为.form


//1) 流程文档部署的生命周期
1) 定义流程文档: 客户端根据自己的业务需求定义流程文档
2) 启动流程引擎之后会自动构造PorcessEngine对象 这样客户端就可以通过该对象获取各种各样的servce对象
3) 部署流程文档  调用流程文档部署命令进行部署 流程引擎收到命令之后开始进行如下操作
    1)将流程文档中定义的元素解析为Activiti的内部表示BaseElement实例
    2)对BaseElement对象再次解析,进行转换为 PVM中的 ActivityImpl对象 或者 TransitionImpl对象
    该过程非常重要, 也是将BaseElement注入PVM的过程
4) 添加缓存: 以上所有步骤完成之后 ,缓存流程定义信息,这样后续节点运转的时候 ,只需要从缓存中取值即可
    无需再次执行以上步骤, 从而大幅提升性能, 默认开启了缓存功能
//////////////////////////////////////////////////////////////////////////////////////////


//////////////////////////////////// 第四章 流程文档解析原理/////////////////////////////////////////
在使用Activiti的时候,会经常根据不同的业务场景绘制不同的流程文档,绘制流程文档过程需要大量元素
例如userTask, 连线, 等.
问题:
那么Activiti是如何解析元素的呢??
如果Activiti中提供的元素不能完全满足业务需求, 又该如何为元素添加扩展属性
如何让扩展的元素拥有更高的通用性???
这就涉及了Activiti中的元素解析,正所谓了解本质,看透其实现原理才能更好的对Activiti解析元素的功能进行扩展,

文档解析基础
2大模型 (JavaWEB基础 不探讨了)
DOM
优点:
    文档解析的时候允许客户端编辑和更新XML内容, 并且可以随机访问文档中定义的元素数据
缺点:
    文档解析的时候会将需要解析的XML文档一次加载到内存,进而映射为Document对象中的树形结构
     基于该特性可以知道该方式在解析大文件的时候 ,内存占用率大 ,元素遍历查找慢 很容易造成性能问题
流模型
优点:
    该方式解析文档的时候,每一次操作只会讲需要解析的节点放置到内存中,从头部开始,读取一段,处理一段
    这样就解决了文档对象模型可能引发的性能问题,该方式内存占用率少,性能大幅提升
缺点:
    该方式解析文档时候,不可以编辑,文件流只能前进不能回退,



因为Activiti将流程文档完全交给客户端定义和使用,所以最终生成的XML大小完全由用户决定 是不可控的
软件架构之初应该避免这种不可控风险, 所以 Activiti最终选择流模型进行文档解析工作

流模型常用的技术有 SAX 和STAX
推模型
    SAX处理方式 是一种事件驱动机制,文档解析的时候每当发现一个元素节点就会触发相应的事件,
    因此客户端需要编写监听触发事件的处理程序,使用该方式解析文档无疑增加了客户端操作的复杂度
    使用起来比较麻烦,不灵活
拉模型
    STAX 处理方式,文档解析时客户端可以定制自己感兴趣的节点主动从 读取器(Reader) 中进行拉取
    选择性的处理节点事件,对比推模型,灵活性大大提高

基于上面的方案: Activiti使用的是Stax方式解析流程文档
STAX提供了两套处理
XML的API ,分别是基于指针的API和 基于迭代器的API  两者解析原理类似,

aCTIVITI 在5.12.1版本之前使用SAX 之后都是STAX方式解析的


为了便于理解,可以把STAX模型理解为一个不可回流的流水管道,该管道主要用来存储流程文档定义信息
读取器可以理解为水龙头, 每次读取器读取文档内容的时候, 客户端可以对读取的流进行处理,也可以不理会,


-------------------->>>>>>>   关于  Activiti 的整体步骤-------------------------------->>>>>>>>>

绘制流程文档 定义的元素需要遵循 BPMN2.0 规范,    此规范将所有的流程定义元素抽象提取为三大要素

Event(事件)  流程的创建,  流转 结束  等 都需要 事件的支持  ,
        例如 在流程文档绘制阶段, 定义开始节点 和结束节点 是一个必不可少的环节,
        可以通过事件机制 为工作流机制 增加 辅助功能
GateWay(网关)   所谓网关 就是用来辅助决定流程实例 最终流转的目的地, 可以用来并行执行节点,
              也可以作为聚合 或者条件分支使用,   常用的 网关类型 有排他网关 并行网关, 兼容网关 三种
Activities(活动) 有生命周期的元素 或者节点 都可以称之为 活动 ,例如  任务节点 子流程, 引用流程 等
            活动节点 可以作为 任何连线元素 的源头  或者 目标

通俗易懂的例子
        可以把流程文档的定义 过程 想象为 一个水流管道
        水流的发源地, 目的地 可以理解为 事件
        水流的分支 或者聚合 都可以理解为网关,
        水流 途径的节点 统称为 活动 ,
        水流 途径的管道 则可以理解为连线
        网关和连线 最终决定 水流的 宏观走向 以及运动轨迹


Activiti  元素 解析 的功能 架构设计图


    元素定义层
            任务  事件 网关, process   .....
        此层完全交给客户端, 开发人员可以结合自己的业务场景组装一系列元素 ,最终完成流程文档的定义工作
        流程文档定义完毕之后 就可以直接调用 元素解析器 实现流程文档解析工作
    元素解析层
            解析器初始化                              解析器解析                       结果映射
            任务解析器                               元素查找                        结果映射
            事件解析器                               元素解析
            网关解析器                               子元素解析
                .....                               自定义元素解析                     数据拷贝

        负责定位流程文档, 初始化元素解析器(包括子元素)  加载自定义的元素解析器, 查找元素解析器, 最终将需要的
        解析的元素以及属性进行解析, 并且封装映射为引擎中的一个个实体对象
    基础支撑层
                元素配置                元素解析器   元素属性承载类,                    自定义元素解析器
                                    引擎配置
        基础支撑层
           DB 连接管理事务管理 等 Activiti 将这些公用组件抽取出来作为 基础模块使用
           为上层的元素解析层提供基础服务支撑


开闭原则:
    如何实现流程文档的解析工作,首先每个元素都需要定义公共属性, 例如id name 等 可以把类似id name等
    公共属性的解析封装为一个通用的解析(),这样程序解析流程文档元素时,只需要调用该() 就可以完成公共属性的解析工作
    流程文档中还有一些元素的属性信息是容易变化的,为什么容易变化?? 因为Activiti版本升级可能会对部分元素添加
    新特性, 此时就需要对扩展元素对应的属性承载类添加一个新的属性定义 ,更致命的问题是
    添加新的属性就需要修改该元素的解析代码, 为了应对类似这样的变化,Activiti为每一个元素包括子元素
    定义了一个对应的元素解析器, 从俄日使得每一个元素解析器只负责一个元素的解析工作,
    这样的好处就是使得元素 和元素解析器一一对应, 分离抽取元素解析器的职责,进而让每个元素解析器之间
    尽量相互独立运行,
    当任意一个元素解析器的逻辑需要修改时不会级联修改其他的元素解析器,  这样流程文档自上而下解析时
    只需要根据元素名称查找元素对应的解析器进行处理即可


元素  与 元素属性承载类(在元素解析的同时, 需要将已经解析完毕的属性值 封装 到指定的类中)  以及元素解析器的对应关系 (元素和元素解析器通常是一对一关系)

比如

endEvent                    EndEvent                EndEventXMLConverter

BaseBpmnXMLConverter类作为所有元素解析器的父类存在
BaseElement 作为所有元素属性承载类的父类存在
所有元素的属性id值必须在流程文档中全局唯一

--------------------------------第5章 <自定义元素解析>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>.....

Activiti中存在默认元素和自定义元素,但是实际开发中 ,可能Activitii提供的元素不能完全满足开发者需求
因此存在2个问题
1) 是否可以自定义元素
2) 如果元素的属性不能满足需求,是否可以扩展元素的属性

自定义元素实战:
   1)如何自定义元素,在哪里定义
   2)自定义元素的名称以及命名空间前缀如何定义
   3)自定义元素添加到父级元素中之后 如何获取

在实际开发中, 开发人员有时为了满足自己的业务需求,需要对流程文档中的 userTask进行扩展
eg: 可以在任务节点中配置该任务的处理人,  节点跳转等附属属性
如果该节点可以进行跳转操作,则需要配置可以跳转的节点集合,范围等一些信息,
这样任务节点解析的时候就可以将扩展的属性解析出来, 并将其注入到PVM中 从而保证流程运转的时候
可以获取到自定义的扩展信息 ,,,


以前说了, 只有 process,userTask,definitions 元素解析的时候 ,,Activiti才会使用黑名单机制
对自定义属性进行解析和存储,看到这里可能有疑问, 除了上面说的3种元素
Activiti是否也对其他元素的扩展属性进行了处理呢???
Activiti并没有对其他元素的扩展属性进行处理,
如果开发者期望在其他元素中使用自定义属性,该如何操作???
自定义元素解析器  即可



------------>
1)
convertToBpmnModel 都干了什么事情??
  BpmnXMLConverter bpmnXMLConverter = new BpmnXMLConverter(); // 实例化此类
              BufferedInputStream inputStream = FileUtil.getInputStream(new File(resource));
              InputStreamSource inputStreamSource = new InputStreamSource(inputStream);
              BpmnModel bpmnModel = bpmnXMLConverter.convertToBpmnModel(inputStreamSource, true, true, "UTF-8");



目前 Activiti 哪些元素支持扩展属性????
        有3个
        根元素 definitions
        任务节点 userTask
        流程元素 process


不管解析何种类型的子元素 , 都需要将元素解析之后的结果 添加到 父元素parseElement中

sparelement 是哪个对象的呢???
parseChildElement 是由哪一个对象调用的呢???
很显然 该() 有具体解析类的实例对象进行调用

比如开始解析任务节点, 则任务节点的解析类 UserTasXMLConverter解析任务节点时就会调用 此方法进行子元素解析

此时 parseChildElement 对象 就是 UserTaskXMLConverter 对象




流程文档中的三大要素 都可以定义执行监听器 和 任务监听器 (仅限于 在任务节点上 定义


监听器 通常作为 扩展元素  extensionElement的子元素进行定义 ,
执行监听器 以及 任务监听器的解析器 分别为
ExecutionListenerParser  和 TaskListenerParser  都继承了 BaseChildElementParser  并且在父类中统一调度

既然 监听器通常作为 extensionElement 的子元素存在
所以首先找到 extensionElement 元素的解析器
ExtensionElementParser




关于黑名单机制

   但是 只有 process userTask  definitions 元素解析的时候 Activiti 才会使用 黑名单机制 对自定义属性进行解析和存储
   *      其他并不可以的,
   *      所以如果期望在其他元素中使用自定义属性, 如何操作???




最新发现  果然


 如果在开始节点 添加了 扩展属性,   那么  果然是不行的 , 因为 startEvent 没有黑名单机制
 所以 需要同时 给开始节点 写一个 XMLConverter

并不需要给UserTask节点 写XMLConverter


/////////////////////////////////////////////////////////////////////////////////////////////


///////////////////////////////  第6章  事件转发器//////////////////////////////////////////////////////////
前几节中 经常看到流程引擎使用事件转发器进行不同事件的转发工作,那么事件转发器是如何工作的呢???
工作原理是什么呢??


全局事件监听器 和 具体类型事件监听器是如何注册使用的呢???
区别
1) 全局: 负责监听所有的事件  具体 只负责部分事件的监听

eg:
开发人员可以将所有流程引擎支持的事件按照业务使用场景进行划分,
可以定义一个类只负责监听器所有与任务有关的事件,
也可以定义一个类只负责变量事件的监听等,

引擎设计具体类型事件监听器的主要意图是方便开发人员细化,归类事件,从而使得事件监听器的职责更加清晰和单一
代码也更加容易维护

事件转发器的先后顺序:
如果 开发人员定义了 一个 全局事件监听器 A   和 具体类型的事件监听器B   分别对TASK_CREATED 的事件进行监听处理
		则首先执行全局事件监听器A 然后执行具体类型的事件监听器B
		同一个事件 可以对应多个 事件监听器

动态添加事件监听器 :
 	1) 因为事件监听器的注册和移除都定义在ActiitiEventDispatcher类中, 所以对于动态添加或者移除事件监听器来说
 		首先需要获取 ActivitiEventDispatcher 对象,由于 ProcessEngineConfigurationImpl持有 ActivitiEventDispatcher对象, 因此该实例的获取非常方便
	2) 通过获取的 ActivitiEventDispatcher 对象进行事件监听器的注册或者移除工作,

 注意:
 	动态的添加事件监听器,当程序或者引擎重启之后,该事件监听器会消失,除非再次执行添加操作,如果程序运行期间
 通过该方式添加了过多的事件监听器,维护起来非常不方便, 而通过配置方式添加到事件监听器会伴随流程引擎
 的初始化而初始化,建议通过配置方式添加事件监听器,更可靠也更加容易维护


日志监听器:
    讲这个之前 先思考几个问题,
        为什么要收集日志数据,
        收集什么样的日志数据,
        收集之后用途
    日志诞生的意义就是记录机器或者系统 何时何地做了何事, 耗费多长时间,接口有无异常信息
    根据日志记录开发人员可以很方便的排查问题,定位原因, 以及观察服务接口是否健壮,性能是否稳定等
    辅助开发人员找出业务系统可以优化的方法和途径,  因此日志数据的采集和分析非常重要,

对于Activiti来说应该采集什么样的数据呢??? 使用数据采集的常见场景如下
1)记录流程实例中任务节点的开始时间,完成时间,处理人,变量信息,持续时间以及该任务节点所属的流程文档
2)记录流程实例开始时间和结束时间
3)记录流程实例运转过程中附带的变量信息(一般以键值对存在)
4)记录流程实例途径的节点信息(流程实例运转轨迹), eg: 按照流程文档模板循规蹈矩的运转还是频繁的进行节点之间的跳转
5)记录是否存在卡顿的流程实例以及流程文档是否经常变动
疑惑:
    直接从DB查询相关数据得到期望结果就可以满足了, 为何要日志记录呢?
        1)如果流程引擎产生的数据量非常庞大并且每次统计分析都需要查询DB,这样频繁操作DB对DB来说负担较大
        2)更致命的问题是DN中存储的部分数据是被引擎 消化 过滤的 并非 第一来源 因此这样统计的数据可能有一些偏差,不精确

上面说了,自定义事件监听器转发事件的过程,为何不以事件监听器为入口,对所有的事件进行监听并且从事件处理类中获取期望的数据
进而从源头上解决日志采集工作, 但是如果对所有的时间进行监控并且处理,可能力不从心,
因为Activiti定义的事件非常多,而且事件对应的处理类也不是完全相同的, 所幸在Activiti 5.16版本中
增加了日志监听器来处理引擎所产生的数据,从而使得开发人员可以很方便的对日志进行收集,管理


由于Activiti将所有的日志数据插入到了 ACT_EVT_LOB中, 可能实际开发会使用Kafka 也可以给ES处理

////////////////////////////////////////////////////////////////

///////////////////////////////////////第7章 流程文档部署原理///////////////////////////////
前面说了 流程文档的部署操作以及元素的解析,那么引擎将流程文档中的元素解析之后又做了什么事情呢??
如果我们期望在流程文档部署动作前后做一系列操作,又该如何实现呢??
如果觉得Activiti提供的默认部署器限制太多,又该如何扩展呢?


部署一个bpmn文件的   整体  断点  走一遍

DeployCmd
        DeploymentEntity deployment = deploymentBuilder.getDeployment();
            deployment 对象中的值
                isNew 为fasle
                deployedAtrifacts 为 null

            deploymentBuilder 对象中的值
                  protected boolean isBpmn20XsdValidationEnabled = true;
                  protected boolean isProcessValidationEnabled = true;
                  protected boolean isDuplicateFilterEnabled = false;

 if (deploymentBuilder.getProcessDefinitionsActivationDate() != null) {
      scheduleProcessDefinitionActivation(commandContext, deployment);
    } //这个括号 走完之后 到了

    preDeployer

    然后走到了 BpmnDeployer

///////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////第8章 流程缓存/////////////////////////////////////////////////
什么是缓存?  就是将系统或者程序中经常使用但是不频繁更新的数据或者对象放置到内存中,以便快速查找
而不必再去DB中查找, 这样做的好处是可以减少系统开销,提高系统运行效率,
在流程引擎部署流程文档之后,会将ProcessDefinitionEntity对象放到缓存中,这样PVM运转时可以直接从
缓存中取出该对象, 而无需再次对流程文档进行解析,从而大大提高流程实例的运转效率


通常情况下,Activiti引擎以一个无状态的方式工作,所有关于流程实例的状态,任务以及其他归档信息都存储在DB中呢
只有在必要的时候流程引擎才会去查询DB, 例如完成任务时,一个流程实例可以休眠很长时间, 因此流程实例不会占用太多的系统资源
这样设计有如下2个好处
1)使Activiti的内存占用率变低,因为只有需要获取流程实例或者任务信息等操作时,才会查询DB
2)允许在一个集群环境下(共享DB) 运行Activiti,  集群中的节点并不需要相互通信,因为DB才是唯一真实的来源
当集群中的任意节点需要获取一些流程状态时,可以直接从DB取出或者写入,在Activiti引擎执行操作期间
mybatis框架 会保持一个 会话缓存来避免同一个会话多次从DB中获取相同的数据
例如 主键值,然而这个会话缓存 的生命周期很短暂, 可以用 朝生夕死形容,因此 会话缓存并不危及集群的运行Activiti的能力

因为Activiti引擎通常运行在web容器 eg: tomcat jboss 并通过http方式提供服务,由于http协议是无状态的
因此可以说Activiti工作方式也是无状态的, 当然 Activiti自己也不会记录操作者操作的数据,只有当客户端需要
操作Activiti时,才会和Activiti建立一个短链接 ,操作执行完毕,连接like关闭,相应的资源也会被回收

由于缓存所有的流程数据可能会占用系统资源和内存,所以通常情况下开发人员期望将永远不会改变的数据作为
优先考虑的缓存对象,eg: 流程文档, 开发人员提供流程文档,流程引擎解析流程文档元素并将其转化为可以执行的结构(更具体的说,就是将流程文档解析
转化为Activiti内部POJO树) 解析工作完成之后,将流程文档的内容以及必要信息存储到DB,eg:描述信息,业务键等
以上过程产生的流程文档永远不会改变,(除非人为进行修改,) 该过程非常消耗系统资源(XML解析总是如此)
因此Activiti使用缓存来存储流程文档解析之后的结果, 这样当启动流程实例或者完成任务时首先尝试从缓存中
加载,如果缓存中没有值,则开始查询DB并在此执行流程文档的解析,最终将解析结果放到缓存中


节点缓存的意义是什么??? 哪些节点支持节点缓存???  节点缓存的值在哪里配置? 节点缓存的数据格式是什么??
eg: 在流程文档中,通常任务节点的使用会非常频繁,如果流程文档部署之后,流程实例运行了一段时间Turuan发现
任务节点的名称,分类或者处理人需要修改,这时怎么办??? 最简单的() 就是直接修改流程文档中不合理的地方
然后再次部署流程文档并启动新的流程实例,但是流程文档的部署涉及流程文档的解析,而解析流程文档是非常耗时的操作
仅仅为了修改任务节点的信息就重新部署文档,难免得不偿失,如果需要频繁修改任务节点的信息,难道每次都要重新部署吗?? 显然不合理

重新部署流程文档只能解决燃眉之急,并不能从根本上解决问题,该方式最终不是一个最优的解决方案,
基于上述问题, 节点缓存类  ProcessDefinitionInfoCache应运而生

该类负责管理流程文档中节点(任务节点,服务任务节点等)的定义信息,该缓存类和其他缓存类一样需要交给
DepolymentManager类进行管理,内部使用Map集合管理缓存数据
该类虽然解决了缓存节点定义信息的问题,但是对于开发人员来说还是存在2个问题
1)缓存的插入以及更新问题
    节点缓存类中并没有提供更新节点缓存的(), 仅仅是在流程文档部署的时候才会对节点缓存数据进行初始化
如果启动流程实例的同时,缓存的流程定义实体对象的数据丢失,那么引擎会再次执行流程文档的部署操作 .
从而引起节点缓存重新添加
2) 缓存数据的持久化
    Map在内存中 重启之后丢失

Activiti 5.19之后引入节点缓存功能


在设计流程文档的时候,可以为任务节点或者process元素添加节点缓存值,这样流程文档部署的时候引擎会
将这些扩展属性值添加到ACT_PROCDEF_INFO表中,  在流程XML中添加 activiti:localization元素
或者activiti:bpmn元素

节点缓存默认是关闭的,如果想使用 则必须开启
enableProcessDefinitionInfoCache()

流程节点缓存 会存储到 ACT_PROCDEF_INFO
此表的INFO_JSON_ID 列关联 ACT_GE__BYTEARRAY表的主键ID列


如果部署流程文档或者运转流程实例时流程定义缓存丢失,
首先, addDefinitionInfoToCache() 从DB中查找节点缓存数据,不管是否查询到都会将其更新到缓存中
疑问:
    如果从DB中没有查找到数据,怎么还需要更新缓存呢??? 首先要明白一个问题
    缓存中的数据是 ProcessDefinitionInfoCacheObject 对象, 因为 createLocaliationValue()
    在处理过程中并没有对该对象进行非空校验,因此即使缓存中没有数据,也需要实例化一个
    ProcessDefinitionInfoCacheObject对象进行存储, 这样也可以保证 createLocaliationValue()
    执行时不会报错,这样设计归根结底是Activiti中的漏洞导致的, 因此使用时多加小心
    createLocaliationValue() 处理逻辑如下
    1)从缓存中获取数据2
    2)解析流程文档中定义的缓存数据
    3)对比以上两者数据,如果两者数据内容不一致,则首先将两者数据进行合并,然后将合并之后的数据更新到DB

节点缓存使用误区
    1)自定义节点缓存类如何替换引擎默认的节点缓存类??
        能否直接设置 ProcessEngineConfigurationImpl 对象中的 processDefinitionInfoCache 开关属性呢?
        但是很遗憾 ProcessEngineConfigurationImpl类中并没有发现任何设置 processDefinitionInfoCache属性值的()
        这个时候应该怎么做呢??
            既然流程引擎配置类没有提供该属性的设置()  ,开发人员可以自定义一个引擎配置类并继承
            SpringProcessEngineConfiguration 从而完成对 processDefinitionInfoCache 赋值操作
    2)命令执行器如何注入自定义节点缓存类
        在 ProcessDefinitionInfoCache 类的构造() 中需要一个 入参, 该参数类型为 CommandExecutor
        因此自定义节点缓存类继承 ProcessDefinitionInfoCache类的同时必须显式调用其父类的构造
        为了确保父类不被破坏,能继续独立运行,所以需要想尽一切办法获取 CommandExecutor对象并将其传递给父类,

        eg:
            public MyProcessDefinitionInfoCache(CommandExecutor){super(ce)};
        那么问题来了,如果客户端使用Spring进行bena的实例化工作, CommadnExecutor 对象作为流程引擎配置类
        中的属性存在,该如何获取?
        因为 CommadnExecutor类的实例化工作完全由引擎内部实现, 很显然通过配置文件,将该自定义节点缓存类
        注入到 ProcessEngineConfigurationImpl类中有点不大可能实现, 既然该方式不太容易实现,不妨换一个思路
        因为之前讲解了 Activiti 配置器, 在此不妨试一试,因为 CommandExecutor可以通过流程引擎配置类实例对象直接获取
    3) ProcessDefinitionInfoCacheObject
        因为 ProcessDefinitionInfoCache 类默认将节点缓存数据封装到 ProcessDefinitionInfoCacheObject中
        该类封装了 流程定义id, 节点版本信息 以及节点缓存数据对应的 ObjectNode
        形如 {"bpmn":{"usertask1":{"userTaskName":"java"}}}
        由于我们使用Redis 因此需要缓存的对象必须实现Java中的序列化接口,
        Activiti在定义      ProcessDefinitionInfoCacheObject 时并没有实现 序列化接口
        所以使用Redis存储肯定会报错, 因此需要自定义一个缓存数据存储类,并实现该类实例对象与
        ProcessDefinitionInfoCacheObject对象可以相互转换
    4)  createLocalizationValues()只会更新DB中的节点缓存数据而不会更新缓存中的数据,这也是Activiti的一个Bug


      节点缓存类 完全不符合Activiti一贯风格 Activiti一贯做法就是将功能抽象为接口并提供默认实现类
      但是Activiti并没有将节点缓存处理类 设计为一个接口,反倒是一个普通的类,而且需要缓存的对象并没有实现
      序列化接口,如果需要自定义节点缓存类 则必须继承 ProcessDefinitionInfoCache 但是该类中定义并没有定义
      无参构造,因此子类必须在自身构造中获取命令执行器 commandExecutor, 这样的设计大大增加了客户端操作的复杂度
      而且自定义节点缓存类需要通过 processDefinitionInfoCache属性注入 ProcessEngineConfigurationImpl类
      但是引擎并没有提供设置 processDefinitionInfoCache属性的().
      综上所述,实现自定义节点缓存类,对于开发人员来说根本上就是一次代码重写,上面的一系列都是需要解决的

      能不能用修改源码的方式解决上述问题?当然可以,但是扩展源码的方式比直接修改源码的方式要优雅一点
      因此如果直接修改源码并对Activiti不合理的地方进行改造,则Activiti框架需要升级时,修改的代码就需要
      迁移到最新版本,这个工作流也不小,则扩展源码则不会出现这样的问题,
      也可以说是一种更优雅更灵活的方案

      节点缓存的使用技巧:
        可以查看一下 哪些节点支持节点缓存功能的小技巧
        首先打开Eclipse  定位到 ProcessEngineConfiguration类,然后查找该类的
        isEnableProcessDefinitionInfoCache() 单击右键, 选Reference-->WorkingSpace
        这样所有可以使用节点缓存特性的类都会被查询出来

        节点缓存功能目前只运用部分节点,如果使用的节点不支持节点缓存,可以使用扩展源码方式改造

////////////////////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////第9章 定时作业////////////////////////////////////////////
对于作业执行器而言,Activiti分为作业执行器和异步作业执行器, 2者设计目的都是为了处理定时作业,
需要了解一下,Activiti5.17之后引入了异步作业执行器,相比作业执行器,异步作业执行器配置性更强,
扩展性更好,但是Activiti提供的新特性,没有经过工业环境太多的实践验证,
所以本章 主要讲 作业执行器实现过程,
作业执行器和 异步作业执行器的 实现原理类似 ,
异步作业执行器  在ProcessEngineConfigurationImpl类的 initAsyncExecutor() 自行学习
//////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////第10章 PVM ////////////////////////////////
之前我们说了 流程文档的解析,并实现了自定义元素属性的解析以及获取工作, 流程文档中的元素解析完毕
之后,是不可以直接使用的,还需对其属性承载类实例(解析结果) 进行一次加工作
因为流程文档中定义的事件  事件 网关 活动(流程三大要素)等信息最终交给PVM管理,
而PVM的运转机制 仅仅依赖于 ActivityImpl 或者 TransitionImpl对象  ,并非元素解析之后的 BaseElement对象

试想一下: 如果现在需要完成一个任务 对于PVM来说需要知道以下几个信息
1)该任务节点归属的流程文档(模板) 任务完成之后流程实例运行的下一个节点,也就是最终目的地等
如果PVM没有持有流程文档中所有元素的解析结果, 可能PVM都不知道如何进行下一步操作
而且对于客户端来说 PVM是一个完全不可触及的黑匣子,
深入PVM 内部实现机制, 有助于开发者掌握如何提高流程实例的运行效率,从而更好地设计流程

PVM原理:
    在学习BaseElement对象的解析之前, 首先需要从全局角度了解PVM 到底做了什么工作
    在流程文档解析并且转化为Activiti内部表示BaseElement 实例的过程中
        Activiti使用开闭原则将流程文档中的元素与元素解析器一一对应, 分离元素解析器的职责
        使得每一个元素解析器的职责更加单一,解析器之间不会相互影响 ,

        同样 开闭原则在对象解析器在这里也体现的淋漓尽致,这里需要强调一点
        本章的解析工作 ,主要是将BaseElement对象转换为 PVM 的ActivityIMpl 对象 或者 TransitionImpl对象
        也许将该过程称之为对象解析 可能会 更加容易理解,


各个过程

    1)定义流程文档
    流程文档的定义工作完全交给 客户端, 客户端可以根据自己的业务需求定制流程文档
    在流程文档的定义过程中客户端可以从元素仓库中获取一系列的元素 组装使用,
    例如 userTask 等  ,该阶段 所有的元素 都处于XML 定义阶段
    2) 元素解析层
    BpmnXMLConverter  类中的 convertToBpmnModel() 所做的工作就是 将流程文档中的元素解析并且转化为
    Activiti 中的内部表示BaseElement实例  并且最终使用流程模型BmnModel 进行保存, (类似内存DB)
    从而使所有的元素解析结果 都可以通过BpmnModel 对象进行获取  ,而无需重新解析流程文档 ,提高运行效率
    元素解析工作完成之后  ,流程文档中所有元素 已经 与  BaseElement 实例对象 一一对应起来

    3) 对象解析层
            bpmnParse.execute()  处理过程, 就是将BaseElement对象中的属性解析并且转化为PVM 中可以识别的
            ActivityImpl 或者 TransitionImpl 对象


    以userTask节点的定义 ,元素解析, 对象解析 3 个阶段说明 ???

                流程文档中的userTask元素 经过元素解析之后 转化为UserTask对象
                UserTask经过对象解析层之后 变为ActivityImpl对象
                UserTask对象中的所有信息 作为 ActivityImpl 对象的属性值存在,
                这样后续操作可以直接通过PVM  获取 ActivityImpl 对象 ,进而获取到任务节点的所有信息

    元素解析与对象解析 2个阶段工作完毕之后,所有的BaseElement 对象 已经与 PVM 中的ActivityImpl 对象 对应起来

    在对象解析阶段, ActivityImpl 对象 需要根据元素实体的类型   填充不同的属性值,
    以方便PVM 按照元素的类型进行区分处理
    该阶段涉及的类 包括 但是不限于 PVM 类 ActivityImpl
                  ActivityExecution
                 任务节点实体类  TaskDefinition
                 活动行为类
                 PvmTransition


  疑问:  直接用元素解析层 岂不是更加简单??? 为何要使用对象解析层呢??
            因为流程文档定义的一些列元素经过元素解析层之后转变为不同的BaseElement对象
            如果没有对象解析层, 那么BaseElement 承载功能太多了,
            后续PVM 所有的操作 都需要对BaseElement 进行区别对待
            最重要一点就是不能全局统一管理
            引入了对象解析层之后,
            所有的BaseElement 最终统一使用ActivityImpl 对象 或者 TransitionImpl 对象
            并且 ActivityImpl 和 TransitionImpl 对象 两者之间和相互获取
            还可以按照元素的类型添加不同的行为类,
            分层的目的是为了 职责更加单一,看起来更加清晰, 代码更容易维护

PVM的入口
    BpmnDeployer.deploy()中调用了 BpmnParse.execute()


对象解析器 初始化先后顺序

前置 -->> 内置  --->> 自定义内置  ----->> 后置

    前置\自定义内置\后置 对象解析器 3种类型的对象解析器  ,引擎 都提供了开关方便客户端操作

    以上所有的对象最终使用List 集合存储
    这样同一个对象可以存在多个 对象解析器 进行 解析处理

    这一点有别于 元素解析器的处理 ,元素解析器 使用Map 结构
    一个元素只能存在一个元素解析器 对其进行解析处理

    所以说 对象解析器 留给客户端的选择更多

    另一方面说明 操作对象解析器 难度 远大于 元素解析器




如何自定义 对象解析器????
        对任务节点userTask对象进行扩展, 在扩展元素中配置当前任务节点的处理人
        这样流程运转到该任务节点时,就可以获取 扩展元素的值 ,
        并将 该值 作为 任务节点的处理人,
        为了简单起见直接使用任务监听器的方式 添加任务处理人,
        难点:
        1) 如何对 任务节点 userTask 的扩展元素进行解析
                自定义任务节点对象解析器, 覆盖系统内置的解析器UserTaskParseHandler
        2)如何存储扩展元素的值
            ActivityImpl 对象存储了 活动节点所有的定义信息,
            所以可以在 userTask元素解析时 ,通过setProperty() 将userTask元素的扩展值存储到ActivityiMPL 对象中
        3)如何获取扩展元素的值
            ActivityImpl对象存储了所有节点的定义信息, 换言之, 只要能够获取ActivityImpl对象
            就可以通过该对象的getProperty() 获取 所有 的元素信息值


        如何自定义任务节点对象解析器
                继承UserTaskParseHandler即可,这样当引擎解析任务节点对象时,就可以直接委托父类
                UserTaskParseHandler对其进行解析, 所以只需要将关注点放到自定义扩展元素的解析 和存储工作即可

/////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////第11章 监听器原理//////////////////////////////////////////
监听器使用场景:
    1)动态分配处理人,eg: 通过监听器可以指定下一个任务处理人或者修改当前节点的任务处理人
    2)调用第三方业务系统,eg: 在监听器中发送邮件或者调用第三方的业务系统,调用第三方系统的时候
    需要特别注意,最好使用异步的方式处理复杂的业务,以房子当前监听器阻塞流程实例的运转
    3)历史节点信息入库,eg: 启动一个流程实例,则需要将开始节点信息插入 ACT_HI_ACTINST表中
    通常历史表的 插入,更新操作 都有系统内置记录监听器执行
    4)获取Spring中定义的bena,因为监听器运行过程中可能需要依赖项目中其他的服务类,而通常这些类的实例化
        以及获取工作完全交给Spring容器进行管理,所以监听器很可能需要获取Spring容器中管理的bean

    监听器 主要分为 2种,   任务监听器 执行监听器

    监听器从使用范围上可以划分为执行监听器和任务监听器,从功能上可以细分为用户自定义监听器以及
    系统内置记录监听器(主要操作历史表,如记录活动节点的开始以及结束操作)
    任务监听器仅仅支持作用于任务节点,而执行监听器可以作用域 流程三大要素等
    2者之间仅仅是应用的节点范围以及类型不同而已,通常执行监听器的应用范围更加的广泛
    任务监听器支持的事件类型有如下4种,
        节点分配处理人 (assignment)
        创建节点 (create)
        任务完成(complete)
        任务删除(delete)
    执行监听器只支持3种,
        开始(start)
        结束(end)
        途径连线(take)
    "
    Take事件类型执行监听器仅仅支持在连线中进行配置和使用, eg: 当前节点完成之后途径连线到达目标节点
        那么就会触发连线上配置的执行监听器,

    需要注意一点,监听器的生命周期与之作用的节点或者连线的生命周期息息相关,紧密绑定
    eg:
       为任务节点 userTask1配置了一个任务监听器
       当流程实例流转到userTask1 节点时,该任务节点的运行生命周期开始并且触发状态变更
       包括给任务节点分配处理人,创建任务节点,完成任务 以及删除任务,
        状态变更则会触发相关事件类型的任务监听器,  当任务节点执行完成之后,流程实例继续向下运转
        该任务节点的监听器运行生命周期伴随着作用的任务节点的结束而结束(除非当前流程实例再次流经该任务节点,如驳回操作)



具体的顺序

流程开始

开始节点   Start --->End
连线 -- >Take
任务 -->Start -----> assignment ----> create ------->> complete ---->End
连线 --->Take
结束节点 ---> Start  ----->End

流程结束



流程实例永远都是以执行监听器为主线运行, 如果流程实例运转的过程中发现了 任务节点 ,则开始执行任务监听器,
如果流程实例离开任务节点 或者 连线, 则该节点的相应的监听器的声明周期 也随之结束(除非 任务节点或者连线 再次唤醒)
任务监听器 执行完毕之后 之后 再次触发执行监听器的end事件 推动流程实例继续向下运转

换言之:任务监听器的诞生 只是为了方便对任务节点的操作而设计的 , 因为流程文档中任务节点的使用非常频繁

任务监听器 和执行监听器  仅仅是 实现的接口类不同
任务监听器 是 Tasklistner 接口
执行监听器 是ExecutionListener接口


在Activiti  中, 对于监听器的创建 ,可以使用如下3种方式

classs   指定类路径, 需要实现ExecutionListner 或者 TaskListener

expression :  表达式方式创建,  该方式 在表达式中已经明确指定需要调用的类 以及 ()
        并可以为需要调用的()传入 参数  形如 : ${bean.doSomething(execution)}

delegateExpression:  该方式通常与Spring 配合使用


关于 这3种方式 对应 由后台哪个类 进行调度

任务监听器
class : ClassDelegate
delegateExpression   DelegateExpressionListener
expressionTaskListener   ExpressionTaskListener

执行监听器
delegateExpression  DelegateExpressionExecutionListener
expression :   ExpressionExecutionListener

内置记录 监听器

Activiti 将运行数据与历史书完全分开存储, 也就是平时所说的运行表 和历史表

内置记录监听器 本质上 还是 监听器 , 只是 由引擎对其 进行调用而已 ,
内置记录监听器的主要职责 就是操作 历史任务节点或者历史环节数据 ,
例如 将 历史数据入库 或者修改  历史表(ACT_HI_ACTINIST) 中的结束事件, 节点的持续时间  节点处理人等等





关于历史解析器 :
    实际项目开发中客户端并没有干预内置的记录监听器, 流程实例运转时,引擎会自动触发并且执行 内置记录监听器
    那么内置记录监听器,是如何被添加到其作用的节点呢????
    内置记录监听器又完成了什么功能呢????

    关于对象解析器来说:  可以存在多个 对象解析器 对  BaseElement 对象进行解析处理

    通常流程 3大要素 在流程实例运转的过程 都会进行 历史数据的归档操作
    也就是平台所说的历史表,
    在此 统称为 历史解析器


        例如 userTask节点, 需要进行历史数据的 归档, 那么该任务节点势必存在多个对象解析器,

        第1类 对象解析器 负责将任务节点解析之后的信息注入PVM
        第2类 对象解析器 也就是历史解析器, 负责获取任务节点解析之后的结果 ActivityImpl 对象并且为该对象
        自动注入内置记录监听器

        只有这样设计, 流程实例运转到该任务节点时, 才会自动触发不同事件类型的内置记录监听器

    为何? 要设计历史解析器,
            首先思考一个问题
                内置记录监听器的作用, 该类型的监听器 完全是流程引擎为了记录或者修改历史数据而设计的
                所以没有必要让客户端干预和配置 ,以降低客户端 使用的复杂度

                附带的好处就是
                    历史数据的归档操作 完全交给内置记录监听器来完成, 从而将  运行数据和 历史数据完全隔离

        历史解析器的职责就是将这一系列的内置记录监听器注入其作用节点所对应的ActivityImpl对象
        这样就可以很方便的为需要的节点添加内置记录监听器 ,同时也方便客户端扩展

        例如 在实际开发中 ,需要记录每一个节点的创建的时间 以方便对流程实例的 运转轨迹进行跟踪

        这时就可以利用 历史解析器为所有的节点 定义一个事件类型为 start 的全局执行监听器,
        从而很方便的对流程实例的运转过程进行跟踪和分析

        思考两个问题
            1) 上面所说的2类对象解析器执行顺序是否可以颠倒
            2) 如何灵活的为每一个节点添加内置记录监听器


历史解析器的本质 依然是 对象解析器 也即 BpmnParseHandlers



Activiti 历史归档级别
none:
    所有的历史归档数据不进行入库记录, 因此性能最高 但是 由于不涉及历史表的操作
    如果配置了, 无法查询流程实例的运转轨迹 以及细节信息
activity:
    归档所有的流程实例以及活动实例, 不归档流程细节, 例如历史任务节点
audit
     默认级别, 归档所有流程实例,活动实例以及提交的表单属性, 所有与用户交互的数据(表单) 都是可以进行跟踪并且统计
full
    历史数据归档的最高级别, giao级别 记录了 所有的历史数据, 因此 流程实例运转最慢,
    该级别,除了保留audit 级别的所有信息之外 还要保存类似流程变量以及 其他可能需要的历史数据






如果程序需要执行 用户配置的监听器, 则首先需要获取该类的实例对象 ,然后调用该对象的notify()
由于用户创建执行监听器的方式不同, 最终封装的对象也不同
内置记录监听器则由引擎直接触发,
class方式创建的执行监听器封装为ClassDelegate对象

 用户配置的执行监听器 可以实现 ExecutionListener接口 ,也可以实现 JavaDelegate接口

*   因为引擎对于class 方式 底层是使用反射技术创建执行监听器实例对象,
* 因此如果期望通过class方式 定义的执行\任务 监听器 获取Spring容器中的对象, 很显然无法获取
* 因为使用反射方式创建 执行监听器的过程中是不会获取Spring容器中的实例对象的



关于 使用 delegateExpression 方式调度

    通常和Spring框架结合使用

    <activiti:executionListenerevnt="start" delegateExpression="${hello}" />
    @Compoment("hello")
    public class MyDelegateExpression  implements Serializable ,JavaDelegate{

        execute(){

        }
    }

通过 delegateExpression 方式定义了  事件名称为 start 的执行监听器
其中 delegateExpression 属性值为 ${hello}

hello 值 也可以是流程实例运行时的变量名称 形如: variables.put("hello", new MyDelegateExpression());



expression方式


public class Person{
    private int a;
}

<bean id ="person"  class ="com.xxx.Person">
    <property name="a"  value="1"/> </bean>

    <activiti:executionListenerevnt="start" expression="${hello.doSomeThing(execution)}" />
    <activiti:executionListenerevnt="start" expression="${hello.doSomeThing1(person,'b',hello)}" />

public class ShareniuExpress implements Serializable {
	public void doSomething(DelegateExecution execution) throws Exception {
		execution.setVariable("myVar", execution.getVariable("msg"));
		System.out.println("444444444444444444444444444444444");
	}
	public void doSomething1(Person person,String b,String cc) throws Exception {

		System.out.println("444444444444444444444444444444444");
	}
}

		Map<String, Object> variables=new HashMap<String, Object>();
		variables.put("hello", 20);
		ProcessInstance startProcessInstanceById = runtimeService.startProcessInstanceById("myProcess:1:4",variables);


Activiti 提供了 几个内置变量

execution, DelegateExecution 类型 保存了 流程执行相关的信息


task DelegateTask类型 ,保存了与当前任务相关信息 (适用于 任务节点) 而且限定为expression类型的表达式


以上两个变量是内置的
DelegateTask类型的变量, 只能在任务监听器中 使用


authenticatedUserId  此变量在启动流程实例前调用IdentityService 的 setAuthenticationUserId()
                    才会由引擎提供, 获取方式很简单,  ${authenticatedUserId}





关于JUEL表达式

在Activiti 中使用非常广泛, 通过表达式 可以动态计算, 一切可以计算的表达式, 从而动态获取值
例如 , 动态 设置 用户任务办理人,  执行一个Java Service

在Acitivit 中 所有表达式中出现的变量 都需要实现序列化接口 , 否则报错
coulod not  find  a variable



因为任务监听器 与执行监听器基本相同,只是实例化的类不同而已,
但是,需要明确一点
当流程实例运转到任务节点时, 会执行任务节点的行为类 UserTaskActivityBehavior并分配任务节点处理人
以及任务节点创建信息,

在任务监听器中 首先触发的是
assignment类型的任务 监听器,  然后触发 create类型的任务监听器


注意 :
    必须在流程文档中定义任务办理人, 或者在到达该任务之前显式调用setAssignee 设置当前任务处理人
    或者调用 taskService.claim() 才可以触发 assignment类型的任务监听器,

    设置任务候选人 或者候选组 不会 触发 assignment 类型的 任务监听器

    delete类型的任务监听器 可以参考 TaskEntityManager 类的 deleteTask()



字段注射模式是什么??
    在ClassDelegate 类的 applyFieldDelcaration() 的处理逻辑, 如果field为空并且
    throwExeceptionOnMissingField 参数为空 true 则程序直接报错,该参数值默认为true
    换言之,如果在流程文档中 为监听器定义了 "字段" 信息,但是没有在监听器(类)中定义这些字段
    则程序就会报错 ,很显然 Activiti设计不人性化, Activiti在5.21版本增加了此模式
    对应 DelegateExpressionFieldInjectionMode 枚举类,该类定义了3种
    1) COMPATIBILTY 通用类型, 如果在流程文档中为监听器配置了字段, 则监听器中必须定义这些字段 否则报错
    2)MIXED 混合类型, 如果在流程文档中为监听器配置了字段, 在监听器中可以不定义这些字段
    3) DISABLED 无效类型,预留字段, 暂时没有提供实现
    可以在流程引擎配置类中设置

    字段注射模式 目前仅仅应用于 serviceTask的行为类, ServiceTaskDelegateExpressionActivityBehavior类中










//////////////////////////////////////////////////////////////////////////////////////////









/////////////////////////////////////////////////////////////////////////////////////////






//////////////////////////////////////////////////////////////////////////////////////////////






为什么要用节点缓存???  (Activiti5.19 引入)
    比如 流程文档运行了一端之后 ,, 想修改任务节点名称 分类 处理人 等等等...

    最简单的办法是 直接修改 流程文档 不合理的地方 然后再次部署流程文档 并且重新启动新的流程水利

    但是如果是 仅仅为了 修改任务节点的信息 就重新部署流程文档, 难免得不偿失,
    如果需要频繁的修改任务节点的信息 ?? 都需要重新部署 吗?? 显然 不合理

    节点缓存 应运而生

    该类负责 管理流程文档中 节点 (任务节点 ,服务任务节点) 的定义信息,
    该 缓存类 和其他缓存类一样需要交给 DeploymentManager 进行管理, 内部使用Map 管理缓存数据
    此类 虽然 解决了缓存节点定义信息的问题, 但是 还有两个弊端
    1) 缓存的插入以及更新问题,
            节点缓存类中并没有提供更新节点缓存的() ,仅仅是在流程文档部署的时候才会对节点缓存数据进行初始化

        如果启动流程实例的同时, 缓存的流程定义实体对象的数据 丢失 ,那么引擎会再次执行流程文档的部署操作
        从而引起节点缓存 重新添加,
    2) Map 持久化, 因为在内存中 重启或者宕机 缓存丢失





节点缓存处理的流程
       起点:  部署流程 或者  缓存丢失
1)   addDefinitionInfoToCache() -->>  去查找DB
2)  addDefinitionInfoToCache() 查到 然后 更新缓存
3) createlocalizationValues()  获取缓存
4) createlocalizationValues() 解析流程文档
5)  createlocalizationValues()  更新DB

如果部署流程文档 或者运转流程实例时流程定义缓存丢失, 则需要执行上述的流程

首先  addDefinitionInfoToCache() 会从DB中查找节点缓存数据,
不管是否查询到 都会 将其更新缓存中,  看到这里的处理逻辑
    疑问::::  如果DB中没有查找到 怎么更新缓存呢???

    首先明白一个问题 ,

    缓存中的数据是 ProcessDefinitionInfoCacheObject 对象
    因为 ,  createlocalizationValues() 在处理过程中 并没有对该对象进行非空校验,
    因此即使 缓存中没有数据 , 也需要实例化一个  ProcessDefinitionInfoCacheObject
    这样才可以保证  createlocalizationValues() 执行时不会博爱错

    这样的设计 实际上Activiti的一个漏洞导致的, 因此使用的时候要多加小心

createlocalizationValues() 处理逻辑如下:
    1) 从缓存中获取数据
    2) 解析流程文档中定义的缓存数据
    3) 对比以上两者数据,如果两者数据内容不一致,则首先将两者数据进行合并,然后将合并之后的数据更新到DB


    节点缓存使用误区
           自定义节点缓存类之前 ,首先考虑几个问题

            1)自定义的的节点缓存类如何替换引擎默认的节点缓存类 ???

    能否直接设置 ProcessEngineConfigurationImpl 对象中的 processDefinitionInfoCache 属性值呢???
        没有
    那么应该如何做???
        自定义一个配置类 继承 SpringProcessEngineConfiguration  从而完成 对 processDefinitionInfoCache 复制操作

            2) 命令执行器如何注入之定义节点缓存类呢???

        在ProcessDefinitionInfoCache 类的构造中 需要 一个输入参数 ,
        该参数的类型是 CommandExecutor, 因此自定义节点缓存类
        在继承ProcessDefinitionInfoCache类的同时 必须显式调用其父类的构造()

        为了确保父类不被破坏,能继续独立运行, 所以需要想尽一切办法获取CommandExecutor对象并将其传递给父类

        public MyProcessDefinitionInfoCache(CommandExecutor ce){
            super(ce);
        }

        那么问题来了, 如果客户端使用Spring 进行bean的实例化工作 ,
        CommandExecutor对象作为 流程引擎配置类中的属性存在 如何获取??????
            因为CommandExecutor 类的实例化工作完全由引擎内部实现,
            很显然, 通过配置文件方式 将 该自定义节点缓存类 注入到ProcessEngineConfigurationImpl类中有点不大可能实现

            既然 不好实现 换一个思路
            Activiti的配置器     因为CommadContext 可以通过流程引擎配置类实例对象直接获取

   3) ProcessDefinitionInfoCacheObject 类
            因为 ProcessDefinitionInfoCache 默认将节点缓存数据,封装到了        ProcessDefinitionInfoCacheObject

            该类封装了 流程定义id 节点版本信息, 以及节点缓存数据对应的ObjectNode
            由于Activiti在定义             ProcessDefinitionInfoCacheObject 类时没有实现Seriailble 接口
            所以使用redis 存储      ProcessDefinitionInfoCacheObject 对象肯定会报错
            因此需要自定义一个缓存数据存储类, 并实现该类 实例对象 和 ProcessDefinitionInfoCacheObject
            实例对象之间相互转换

    4) createlocalizationValues() 只会更新DB中的节点缓存数据 而不会更新缓存中的数据, 也是Activiti的Bug

    节点缓存类完全不符合Activiti的一贯设计,  因为Activiti 的一贯做法就是将功能抽象为接口并提供默认实现类
    但是 Activiti 并没有将节点缓存处理类  ProcessDefinitionInfoCache 设计为 接口
    反倒是一个普通的类, 而且需要缓存的对象并没有实现 Seriable 接口
    如果客户端需要自定义节点缓存 则必须继承 ProcessDefinitionInfoCache 类
    大师该类中并没有定义无参构造,
    因此子类必须在 自己的构造中获取CommandExecutor
    这样的操作设计大大增加了客户端操作的复杂度,
    而且自定义节点缓存类需要通过 processDefinitionInfoCache 注入 ProcessEngineConfigurationImpl类
    但是引擎并没有提供任何设置 processDefinitionInfoCache 属性的()



    综上所述 实现自定义节点缓存类, 对于开发人员来说 根本就是一次代码重写,

    能不能不使用修改源码的方式解决上述问题???
        当然可以, 但是扩展源码的方式比直接修改源码的方式要优雅一点
        因为如果直接修改源码 并且对 Activiti不合理的地方进行改造,
        则Activiti框架需要升级时,修改的代码就需要迁移到新版本,
        这个工作量也不小, 而扩展源码 则不会出现上述问题,
        更优雅 更灵活


目前支持 节点缓存的只有 UserTask  ,ServiceTask , ScriptTask
但是 可以为不支持的 扩展源码改造




如何自定义作业处理器 ????

    以 定时启动流程实例作业的处理器, TimerStartEventJobHandler  如果需要使用该功能
    就必须使用定时开始事件  而使用定时开始事件需要大量的配置

    例如 配置开始 时间 ,循环次数,
    但是 基于配置的方式不灵活,
    例如 流程启动的时间 需要通过程序自动计算,























Activiti 将客户端所有的请求操作 组装为 一个个命令类
        首先说明  不可能在一个()中完成非常复杂的逻辑, 目的是为了使() 尽可能单一和复用,也节省后期维护成本
        一个真正实现功能的() 代码量 其实是很少的  一般都是从全局角度做一些统筹工作



Activiti的 命令拦截器

如果不加前置拦截器
第一个是 LogInterceptor
事务
上下文
后置
最后一个是 commandInvoker


///////////////
所有的命令拦截器一般直接继承 AbstractCommandInterceptor 类
由于该抽象类的execute() 并没有进行throws 抛出异常声明
所以该类的任何子类在实现 该() 时 ,()签名中不可以声明throws异常
因此如果execute() 在执行过程中出现异常, 则 需要开发热源捕获异常信息并且进行处理

由于日志拦截器 仅仅是 记录日志而已 , 所以几乎不会抛出异常 , 因此 该类无需进行异常的 捕获 工作








关于PVM 如何运转 ????

    从
    runTimeService.startProcessByXX 开始

    start 相关参数

    processDefinitionKey   流程定义key
    businessKey  业务key
    tenantID 租户id
    messageName   消息方式 启动 对应流程文档中message元素的name值
    Map<Stirng,Object>  变量信息




Activiti 允许开发人员 在流程文档中 为流程或者子流程定义dataObject元素
该元素可以指定变量的id ,名称,数据类型等
支持的数据类型有 string, boolean, datetime,double int,long
流程实例启动之后 会将dataObject元素的信息自动转化为 流程实例变量存在
变量名称 对应dataObject元素中定义的name 值
开发人员也可以通过dataObject元素中的子元素 exetensionElements 为转换之后的流程变量提供默认值




区别 流程实例 和执行实例

processInstace.setVarialbes(dataObjects)  主要用于设置变量


设置变量的 几个方式

  ProcessInstance startProcessInstanceByKey(XXX, Map<String, Object> variables);
        在流程实例启动时设置变量 (全局变量 )

  void setVariables(String executionId, Map<String, ? extends Object> variables);
  负责为流程实例设置变量

  void setVariableLocal(String executionId, String variableName, Object value); //负责为执行实力设置变量(局部变量)
  void complete(String taskId, Map<String, Object> variables)   完成任务时设置变量 (全局变量)
  void setVariableLocal(String executionId, String variableName, Object value);  为当前执行的任务设置局部变量


  流程实例 和执行实例的关系

  通常情况下, 如果流程不存在分支 或者 多实例节点, 则流程实例id 和执行实例的id 相同
  两者的值 分别对应  ACT_RU_EXECUTION  PROC_INST_ID 和 ID_

  了解一下 执行实例树  (3级)
        activityid  =null;    1级
        activityid = 流程实例id ;  2级
        XXX   XXX   XXX   执行实例n  3级


  setVariables 和 setVariablesLocal 区别

        setVariables设置的变量都是针对流程实例的(全局变量)     也就是 上图中的 2级节点
        setVariablesLocal 可以针对 流程实例分支 (局部变量)     也即 执行实例   对应的是第3级


默认情况下 变量都是针对流程实例的, 而局部变量的适用范围  就比较小(与执行实例的生命周期绑定 )
只能针对执行实例 ,执行实例结束之后 ,后续的流程实例 无法通过 ACT_RU_VARIABLE 获取该变量值
只可以通过ACT_HI_VARINST 表获取该变量值

使用局部变量的好处
    执行实例 和 流程实例 可以使用相同的变量  名称, 而且相互之间不会冲突, 使用全局变量,则变量名称相同时
    后者会替换前者





PVM的运转原理

流程实例启动之前, Activiti 会判断当前流程文档中的process元素 是否配置有事件类型为start的执行监听器
如果有 立即执行, 执行完毕之后 Activiti 会找到流程文档的源头
也就是开始节点, 然后触发开始节点中事件类型为start的执行监听器,

创建ActivityImpl对象时 会根据当前节点 或者网关的类型为其添加不同的行为类

也即 执行完开始节点中事件类型weistart的执行监听器之后 ,会执行开始节点的活动行为类 中的  execute()

该() 决定了流程实例的最终走向,
例如 流程实例是否可以离开当前节点, 途径哪些连线, 最终流向何方,
都由开始节点的行为类进行干预,

程序执行完开始节点的行为类中的execute() 之后

如果流程实例可以继续向下运转,  则会执行当前节点中事件类型为end的执行监听器, 表示该节点已经执行结束
流程实例以及继续向下运转,

在流程运转到下一个节点之前, 会途径连线,并且触发连线中事件类型为take的执行监听器
进而到达下一个节点(目标节点)   以此类推

通过上面流程运转的原理可移植
    流程实例的运转过程中需要处理如下几个信息 ,

    1) 需要获取当前的节点信息,
    2) 获取当前节点的活动行为类
    3) 获取当前节点可以途径的连线信息并且触发事件类型为take的执行监听器
    4) 途径连线之后需要将目标节点的信息 插入到DB 中

    换言之 :
    当前节点执行完一系列的操作之后会告诉引擎最终可以途经的连线, 途经连线则会到达目标节点
    到达目标节点并且执行完一系列的操作之后
    流程实例有可能如上述所示继续运转 ,知道流程实例结束为止

   对于该处理过程而言, 处理的节点不同, 但是步骤确实相同,

   这样 的场景  设计使用 职责链模式 最合适不过了


    Context对象 存储了了职责链  需要的公共属性值, 并且负责按照顺序依次调度职责链中的类
    这样设计的好处是分类了 每个()的功能职责, 从而使 () 复用性和 移植性更强


原子类
// 流程启动原子类  第一个触发的原子类 , 里面设置了下一个需要处理的原子类 PROCESS_START_INITIAL
 AtomicOperation PROCESS_START = new AtomicOperationProcessStart();
 //流程启动准备原子类   第二个触发的 里面设置了下一个需要处理的原子类  AtomicOperationActivityExecute
  AtomicOperation PROCESS_START_INITIAL = new AtomicOperationProcessStartInitial();
  AtomicOperation PROCESS_END = new AtomicOperationProcessEnd();
  AtomicOperation ACTIVITY_START = new AtomicOperationActivityStart();
  //第三个触发  活动节点执行原子类 会触发到 开始节点的行为类(NoneStartEventActivityBehavior) 并执行该对象的execute()
  行为类中 会找到符合条件的 连线  -->>
  AtomicOperation ACTIVITY_EXECUTE = new AtomicOperationActivityExecute();

  AtomicOperation ACTIVITY_END = new AtomicOperationActivityEnd();
  //第4个触发--> 此为 通知连线完成原子类 (
  (
  主要负责触发当前节点中配置的事件类型为end的执行监听器以及制定下一个需要处理的原子类

  )
  AtomicOperation TRANSITION_NOTIFY_LISTENER_END = new AtomicOperationTransitionNotifyListenerEnd();
  //第5个触发  连线销毁原子类
  (
  获取当前节点的目标节点也就是流程实例最终需要运转到的节点,
  如果 存在目标节点
  触发  TRANSITION_NOTIFY_LISTENER_TAKE
  如果不存在目标节点
  触发  TRANSITION_NOTIFY_LISTENER_END
  )
  AtomicOperation TRANSITION_DESTROY_SCOPE = new AtomicOperationTransitionDestroyScope();
  //该类主要负责触发连线中类型为take的执行监听器,获取和设置当前节点的目标节点信息,
  并且设置下一个需要处理的原子类  TRANSITION_CREATE_SCOPE
  AtomicOperation TRANSITION_NOTIFY_LISTENER_TAKE = new AtomicOperationTransitionNotifyListenerTake();
  //该类负责设置下一个需要处理的原子类 TRANSITION_NOTIFY_LISTENER_START
  AtomicOperation TRANSITION_CREATE_SCOPE = new AtomicOperationTransitionCreateScope();
  //该类负责查找当前节点需要到达的目标节点以触发目标节点类型为start的执行监听器
  (
  流程实例到达目标节点之后,首先要做的工作是创建目标节点以及将该节点的信息入库,
  创建目标节点之后,如果目标节点不能推动流程实例继续向下运转,则其就是原子类的结束标志
  )
  AtomicOperation TRANSITION_NOTIFY_LISTENER_START = new AtomicOperationTransitionNotifyListenerStart();

  AtomicOperation DELETE_CASCADE = new AtomicOperationDeleteCascade();
  AtomicOperation DELETE_CASCADE_FIRE_ACTIVITY_END = new AtomicOperationDeleteCascadeFireActivityEnd();


第一个执行的原子类     performOperation(AtomicOperation.PROCESS_START);





关于
    忽略节点, 属于 Activiti5.17版本的新特性, 该操作用来设置 流程实例运转过程中 是否可以忽略当前的活动节点

    如果想要使用忽略节点功能 变量名称 必须为 _ACTIVITI_SKIP_EXPRESSION_ENABLED 且必须为Boolena 否则 程序报错

    用法 给某一个 节点配置上 skipExpression  ${_ACTIVITI_SKIP_EXPRESSION_ENABLED}

    启动流程实例时 设置一个流程变量
    map.put("_ACTIVITI_SKIP_EXPRESSION_ENABLED",true);
        startByXXX( map)





////////////////
关于行为类



    在 创建 ActivityImpl的过程中 ,会根据节点的类型注入不同的活动行为类
    行为类主要完成什么 功能???

        行为 就是 受大脑中的想法或者意识支配完成一系列的动作

        例如: 现在需要完成一个任务,
        对于任务节点的执行行为来说

        需要考虑几个情况
            1) 当前任务是否满足条件  ,任务完成之后 流程实例可以途经的连线, 最终到达的目的地,
            换言之
                任务节点的行为类 决定了 该流程实例的最终走向


Activiti 将所有活动行为类的创建工作交给活动行为工厂类完成

        在什么地方初始化的呢??

        ProcessEngineConfigurationImpl的 getDefaultDeployers()  中

结论:
Activiti会将一些复杂对象的创建工作交给相应的工厂类,活动行为类也不例外,所有活动行为类的
创建() 都定义在 ActivityBehaviorFactory接口中

为何需要通过抽象工厂进行一系列对象的创建工作呢? 而不是将每一个对象的创建() 分散到不同的类中呢?

好处: 同一个地方集中创建 好处就是 可以对创建的实例对象集中管理, 也方便对抽象工厂类维护
    其他好处就是 当开发人员需要扩展活动行为工厂类的默认实现时,只需要在同一个地方进行操作即可
    从而降低客户端使用的复杂度,eg: 需要扩展某个活动行为类的默认实现时,只需要自定义一个类
    并继承 DefaultActivityBehaviorFactory 覆盖该活动行为工厂类的创建() 即可




一个场景:

    员工可以发起,请假申请 ,如果请假天数 >=1 提交项目经理
                         如果 >=2   提交项目经理, 同时 部门主管
                         如果 >=3      项目经理 部门主管 CTO


        排他网关的出口 需要配置条件表达式,  其内部维护决策结果(Boolean类型

        当流程实例运转到排他网关时   ,流程引擎会自动探测其所有出口信息 ,自上而下检索

        如果发现出口的决策结果返回true ,或者该连线配置的跳过表达式 成立, 则立即停止检索




  <process id="extensionOperationProcess" name="ext" isExecutable="true">
    <startEvent id="start" name="Start"></startEvent>
    <endEvent id="end" name="End"></endEvent>
    <exclusiveGateway id="exclusivegateway1" name="Exclusive Gateway"></exclusiveGateway>
    <userTask id="usertask1" name="项目经理"></userTask>
    <userTask id="usertask2" name="部门主管"></userTask>
    <userTask id="usertask3" name="CTO"></userTask>
    <sequenceFlow id="flow1" sourceRef="start" targetRef="exclusivegateway1"></sequenceFlow>
    <sequenceFlow id="flow8" sourceRef="exclusivegateway1" targetRef="usertask1">
      <conditionExpression xsi:type="tFormalExpression"><![CDATA[${day >=1}]]></conditionExpression>
    </sequenceFlow>
    <sequenceFlow id="flow3" sourceRef="exclusivegateway1" targetRef="usertask2">
      <conditionExpression xsi:type="tFormalExpression"><![CDATA[${day >=2}]]></conditionExpression>
    </sequenceFlow>
    <sequenceFlow id="flow4" sourceRef="exclusivegateway1" targetRef="usertask3">
      <conditionExpression xsi:type="tFormalExpression"><![CDATA[${day >= 3}]]></conditionExpression>
    </sequenceFlow>
    <sequenceFlow id="flow5" sourceRef="usertask1" targetRef="end"></sequenceFlow>
    <sequenceFlow id="flow6" sourceRef="usertask2" targetRef="end"></sequenceFlow>
    <sequenceFlow id="flow7" sourceRef="usertask3" targetRef="end"></sequenceFlow>
    <dataObject id="dObj123" name="shareniu" itemSubjectRef="xsd:string">
      <extensionElements>
        <activiti:value>shareniu123</activiti:value>
      </extensionElements>
    </dataObject>
  </process>


排他网关的分支条件必须在 流程文档中进行定义 , 分支条件的配置比较简单, 一般为 boolena 类型表达式,



思考2个问题
    1) 启动流程实例之后  同时设置 day 变量为2   流程实例 如何运转呢???
    2) 将  互换位置    流程实例运转哪一个节点呢 ??
     <sequenceFlow id="flow1" sourceRef="start" targetRef="exclusivegateway1"></sequenceFlow>
     <sequenceFlow id="flow8" sourceRef="exclusivegateway1" targetRef="usertask1">
       <conditionExpression xsi:type="tFormalExpression"><![CDATA[${day >=1}]]></conditionExpression>
     </sequenceFlow>
     <sequenceFlow id="flow3" sourceRef="exclusivegateway1" targetRef="usertask2">
       <conditionExpression xsi:type="tFormalExpression"><![CDATA[${day >=2}]]></conditionExpression>
     </sequenceFlow>


        第一种情况 : 肯定是 流转到项目经理节点,
        第二种情况 : 肯定是  流转到部门主管节点,
                因为流程实例运转过程中 遇到排他网关, 会自动检索网关的所有出口,
                检索的先后顺序是按照流程文档中 定义的顺序 自上而下 开始的,
                如果遇到分支决策 结果为true 则停止检索



Activiti 将数据添加到DB中 分为2个阶段

1) 将数据添加到会话缓存
2) 将会话缓存中的数据刷新到DB

更新也分两种
1)会话缓存 方式更新
2) 直接操作SqlSession 更新数据
删除也是
1) 会话缓存方式删除
2) 操作 SqlSession 进行删除



Activiti 存储的 MyBatis
每一个使用Mybatis 操作DB的工作 都是基于SqlSessionFactory 对象实现,
该实例负责对外提供DB的连接和 操作
Activiti使用mYbAtis 作为数据访问层,

首先思考一个问题,, DataSource 是如何被初始化的????? 从配置类 中开始的



在使用mybatis时,首先要做的工作就是配置一系列的映射文件,
从而使得实体类和 表 一一映射
MyBatis db 表的操作都是基于 SqlSessionFactory 对象进行的

SqlSessionFactory 的默认实现类 为 DefaultSqlSessionFactory ,
因此想要使用MyBatis ,获取 SqlSessionFactory是一个必不可少的环节

实体类和 DB 表的映射

Activiti是如何封装数据访问层的, Activiti 和MyBAtis 集成时,
会读取项目中配置mybatis的映射文件    mapping.xml

  <settings>
    <setting name="lazyLoadingEnabled" value="false" />
  </settings>
  <typeAliases>
    <typeAlias type="org.activiti.engine.impl.persistence.ByteArrayRefTypeHandler" alias="ByteArrayRefTypeHandler"/>
  </typeAliases>
  <typeHandlers>
    <typeHandler handler="ByteArrayRefTypeHandler"
                 javaType="org.activiti.engine.impl.persistence.entity.ByteArrayRef"
                 jdbcType="VARCHAR"/>
  </typeHandlers>


第1个是开启懒加载
第二个 添加了一个TypeHandler


映射文件  和 数据库表  实体类的关系
Attachment.xml    ACT_HI_ATTACHEMENT   AttachmentEntity

都在 org.acitivit.engine.impl.persistence.entity







关于Activiti 内部删除 数据

        DbSqlSession 类
    * 3) 为什么需要判断 是不是 HasRevision 实例 ??
      * 涉及到了DB 的乐观锁
      *  乐观锁通常情况下 认为数据不会发生冲突, 所以在数据更新或者提交时,才会正式检测数据是否冲突
      * 如果发生了冲突, 则将错误信息反馈给客户端, 让客户端决定下一步该如何处理
      *
      * Activiti是如何使用乐观锁的呢???  加了一个REV_列
      * 读取数据时将版本列的值一并查询出来, 并将其作为数据一部分,
      * 这样当客户端操作数据时,需要判断D表中的版本值 与当前数据的版本值是否一致,如果两者一致
      * 则给予更新操作,(更新一次版本+1 ) 否则将当前数据作为过期数据处理
      *
      * 如果 persistentObject 不是 HasRevision 对象 ,就意味着没有使用到乐观锁,
      * 就直接执行 slqSession删除数据
      * */
      if (persistentObject instanceof HasRevision) {
        int nrOfRowsDeleted = sqlSession.delete(deleteStatement, persistentObject);
        if (nrOfRowsDeleted == 0) { //表示并没有删除数据 ,因此程序直接报错
          throw new ActivitiOptimisticLockingException(persistentObject + " was updated by another transaction concurrently");
        }
      } else {
        sqlSession.delete(deleteStatement, persistentObject);
      }


  *  也需要分析一下
  * Activiti 存储了会话缓存数据之后 ,是如何将 缓存中的数据刷新到DB的
  *  查看 finaaly中   关闭命令拦截器

CommadContextInterceptor 类





  * 假如客户端A 发送了一个命令 将 GroupEntity对象 添加到DB
  * 该命令经过了一系列的命令拦截器链之后 命令开始原路返回,, 并且内存中已经存储了 GroupEntity对象 (将其称之为原值
  * 当执行到命令拦截器之前 程序还没有开始进行 flushSessions() 动作时,
  *
  * 客户端A 或者 客户端B 对 GroupEntity 中的属性值进行了修改,
  *
  * 那么当客户端A 执行 flushSession() 时   因为GroupEntity对象中的属性值与原值不一致 则会触发更新操作
  *
  *
  * 假如同样的修改操作
  * 客户端B修改了对象的id值 , 思考一下会发生更新操作吗???
  * 不会,为什么??
  *  因为GroupEntity 类中的 getPersistentState() 返回对象中 ,并没有对id值进行定义
  * 因此修改id(getPersistentState()中之前没有定义的属性值 ) 不会触发更新操作
  *
  * 更新操作判断的核心点 只在于 关心实体类中 getPersistentState() 所定义的属性, 其他属性是否变化一概不理会,
  *
  * 容易出现2个缺陷
  * 1) 例如 对于ID   (通常对应于DB中的主键,  如果Activiti运行在一个高并发的场景中, 那么 就有可能出现问题
  * 又如客户端A生成了一个主键ID 值, 程序还没有来得及进行flushSessions操作,
  * 这时客户端B 又需要生成一个主键id值 ,这个值就有可能占用了 ,
  * 由于DB中的主键值不能相同,  由于DB中的主键值不能相同,因此通常情况下 ,并发量大的长泾镇 主键id建议使用 UUID
  * 2) 会话缓存中的数据在没有刷新到BD之前,如果系统宕机, 则会话缓存中的数据丢失,
  * 因此使用该功能有风险, 因为引擎并没有提供容错机制
  *
  *
  * 通过上面分析 可知 只有 Persistentobject 接口中 getPersistentState() 定义的属性值发生了变化
  * Activiti 才回去更新对象, 这对于客户端来说 ,可能有点不灵活
  * Activiti 也提供了 update(String statement, Object parameters)  可以直接通过SqlSession 对象更新数据
  *
  * Activiti自身会话缓存机制设计的很简单, 性能稳定,但是有局限性 ,不适用于复杂场景,
  * 在实际开发中, 如果比较复杂,可以结合MyBatis中的缓存机制使用
  *


默认的DBIdGenerator类生成id值存在2个缺陷
1)如果idBlockSzie开关属性值比较小 则会频繁查询DB 效率低下
2) 高并发情况下可能会造成主键值冲突





默认情况下 Activiti 根据变量的名称 查询到变量的类型时,会通过变量管理类依次查询所有的变量处理类,直到查找到为止
如果开发人员没有定义 custompostVariable属性值, 则SerrializableType 用于处理序列化变量
虽然这种() 是可取的 ,但是 有几个缺陷

1)卡法人员必须谨慎使用  serialVersionUID字段
2)对于重构不友好,改变一个类或者字段名 就需要哦重新 修改源代码
3) 序列化的对象时无法进行DB操作的

实际开发中
可以把JSON字符串存储到 ACT_RU_VARIABLE 表中的 TEXT_字段 ,并通过DB直接查询
但是 这种实现方式受限于字符串的最大长度   ,默认情况下 Acticiti 定义为4000个字符








在实际项目开发中有这样的例子, 假如一个部门内部投票, 该部门有5个人, 那么当5个人都进行投票时可以分为如下情况
1) 该部门所有的人都需要投票,当所有人投票完毕,则当前节点结束,路程实例继续向下运转(人人参与)
2)该部门所有的人都需要参与投票,只要有一半以上的人同意,则当前节点结束,路程实例继续向下运转(部分人参数与)
3) 该部门只要部门经理投票通过 ,则当前节点结束,流程实例继续向下运转(一票否决)
4) 该部门入职一位新人,新人也需要投票,所有人投票完毕,则当前节点结束,路程实例继续向下运转(人员增加)
5) 该部门离职一位员工,离职员工不需要投票,其余所有人投票完毕,则当前节点结束,路程实例继续向下运转(人员减少)
6) 该部门有一个员工出差,让其他员工代替投票,则当前节点结束,路程实例继续向下运转(人员不变,但是节点处理人需要变化)
7) 该部门中职位不同投票的权重也不同,eg: 5个人员权重加起来为1,部门经理为50%, 普通员工10%,然后根据权重计算投票结果(权重不同)
8) 该部门所有人依次开始投票,普通员工一个个投票,然后组长投票,最后部门经理投票并统计结果(串行结果)

并行多实例行为类是 ParallelMultiInstanceBehaviror 串行多实例是 SequentialMultiInstanceBehavior



activiti:candidateUsers   属性 表示可以处理当前任务的候选人集合, 如果存在多个候选人, 使用 , 进行分割
isSequential true表示当前任务节点并行执行, false表示串行执行

loopCardinality  如果配置为2 ,表示当前任务循环2次结束

启动会签流程之后 ACT_RU_VARIABLE表会出现 几条数据
1) nrOfInstances 实例的数量
2) nrOfCompletedInstances 已经完成的实例个数
3) nrOfActiveInstances  单签还没有完成的实例个数,如果使用串行的方式实现多实例则该值永远为1
4) loopCounte: 循环次数,
    串行方式计算多实例任务是否可以离开当前节点依赖该值
        对于此方式而言, 该值从0开始,当多实例中的任意一个任务完成之后 ,该值 +1
        该变量的操作 可以参考  SequentialMultiInstanceBehavior类中的leave()
    并行方式不依赖该值

同时查看ACT_RU_tASK 表,  多实例任务的 ASSIGNEE_列的 ,该列为空并没有数据,因为候选人或者候选组
数据存在ACT_RU_IDENTITYLINK表, 因此想要完成该任务节点,首先需要 认领任务,
taskServcie.claim("taskid","assignee")
如果继续认领 ,则报错, 因为已经被认领的任务是不能被再次被认领的

也可以通过TaskServcie.setAssignee() 修改 ASSIGNEE 值 ,该()不会检查任务是否被拾取

归还任务就是将 ACT_RU_TASK 表中的 ASSIGNEE_值设置为空,
taskServcie.unclaim("taskid");

代理任务
 比方说
 zs 可以处理userTask1, 但是zs 现在出差 没办法办理该任务,  需要将任务委托给, ls处理
 对于该需求来说 zs 为任务的归属者,  ls为任务的办理人,
 对于OWNER_列 仅仅是记录任务的归属者, eg: 同一个任务被反复代理,但是Activiti并没有记录代理的操作痕迹
 实际项目开发中 可以扩展一张表记录代理的详细信息

   <userTask  id="task1479796561062" name="会签" activiti:assignee="${assigneeUserId}" >
             <multiInstanceLoopCharacteristics  isSequential="false"
             activiti:collection="${QbUtil.getQbList(id)}"
             activiti:elementVariable="assigneeUserId" >
             <completionCondition>${nrOfCompletedInstances/nrOfInstances >= 0.75}</completionCondition>
             </multiInstanceLoopCharacteristics>
         </userTask>

 activiti:assignee 表示任务的处理人,  该值 和    activiti:elementVariable 配合起来使用

activiti:collection 是集合的名称, 引擎会根据集合中元素的个数生成对应的执行实例 (生成执行实例的个数与集合的元素的个数一直)
    eg: 集合中元素个数 是 5, 表示当前的任务会循环 5次,  流程实例到达该任务节点之前需要设置 此变量

completionCondition 表示当前任务通过的条件, 对于该配置而言,
eg: 现在有4个投票, 则其中任意3个人投票之后,当前的任务节点结束,如果不配置该值,默认情况下通过条件为1(在此场景中就是 4个人都得投票)


加签: (在userTask1 上 加一个处理人)
减签: (将指定的任务数据删除即可)


使用会签的建议:
    1) 对于并行多实例而言, 如果离开当前节点的条件满足,则该节点所有的出现都会执行,多实例没有通过或者
    不通过的概念,因此 后面加一个排他网关,
    2) 配置权重时尽量使用intrger  避免造成数据丢失
    3) 设置变量时需要考虑流程实例级别的变量与执行实例级别的变量之间的区别


    ////接管Activiit
    虽然可以通过TaskServcie查询出,但是 如果当不满足项目开发需求时,那么就需啊哟考虑如何扩展这些功能

    Activiti可以通过候选组或者候选人的方式为任务指定办理人,
    该操作涉及到的表有
    ACT_RU_tASK  任务有关的信息
     act_ru_identitylink  存储候选组或者候选人的信息
      ACT_HI_IDENTITYLINK   用于对候选人或者候选组的信息进行备案

      默认情况下 用户与组需要操作的表有
      ACT_IDUSER 维护用户信息
      ACT_ID_GROUP 维护组信息
      ACT_ID_MEMBERSHIIP 用于维护用户与组之间的关系,
      引擎默认支持用户或者组 但是通常情况下 需要用到 用户(人)  角色, 部门等
      换言之 Activiti必须支持多维度的配置,并非单维度的,这时就需要考虑如何扩展Activii的功能
      尽量使用 扩展源码的方式而非直接修改源码的方式
      1)接管 Activiti映射文件
        重写配置的 getMybatisXMLConfigurationStream();
        HistoricIdentityLink.xml    hi_identitylink表
        IdentityLink.xml            ru_identityLink表
        mapping.xml : mybatis全局配置文件
                把自带的这两行 删除掉 修改成我们自己的
                    <mapper resource="org/activiti/db/mapping/entity/IdentityLink.xml" />
                        <mapper resource="org/activiti/db/mapping/entity/HistoricIdentityLink.xml" />
        如果觉得映射文件中的SQL不够灵活可以直接在映射文件中修改
      2)如果 ACT_ID 三张表不能满足开发需求 禁用就可以了
            dbIdentityUsed =fasle  就不会创建这3张表了
      3)自定义RBAC表

      4)扩展任务节点参与者表
      ACT_RU_IDENTITYLINK表 可以存储任务节点的候选人 或者候选组, 在使用时可以将该表的
      GROUP_ID_ 字段存储角色 id 这样人员与角色的问题就解决了 ,
      那么怎么存储部门id呢?? 很显然 需要为 该表增加一个字段存储部门id值
         ru_identitylink和 hi_identitylink 都要加
      5) 自定义任务节点参与者命令类,
      IdentityLinkEntity 类   是 ACT_RU_IDENTITYLINK表对应的映射文件类, 该类中并没有定义
      部门id属性,所以需要考虑如何扩展 此类, 首先定义一个类继承该类
      extends IdentityLinkEntity类  重写 getPersistentState()  添加deptId值

        如果想操作 自己继承的类, 那么对于该类的SQL执行id值(插入操作)应该是 insertShareniuIdentityLink

        为了保证原来的功能好用,不要把SQL执行id值为 insertIdentityLink的标签删除

        把  insertShareniuIdentityLink的这个封装成一个命令类


        这样就可以在流程设计器上 加部门属性,
        然后 任务解析器解析改属性值, 最后流转到此节点时,需要获取该属性解析之后的结果
        并进行相应的操作,
        最后将获取到的数据添加到ACT_HI_IDENTITYLINK表中
        重写userTaskActivityBehavior的 handleAssignments()

       PvmActivity activity = execution.getActivity();
        ManagementService managementService = execution.getEngineServices().getManagementService();
        Object property = activity.getProperty("");//获取扩展属性值
        //然后就可以判断部门 这里是否 填写了,  填写了 就用自己的命令类 添加到 act identityLink 就完事了


自定义待办SQL
    ru_identitylink表中已经成功添加了group_id  如果使用Activiti本身的用户待办任务查询功能 很显然是查询不到的
    因此需要书写符合自身业务需求的查询待办SQL语句,


///////////////////////////////////
随着时间的推移, BPM的定义范围逐步扩展,不仅用来满足无纸化办公,现在BPM是一种企业集成技术,
 作为面向服务系统架构SOA
 企业应用继承 EAI
 企业服务总线 ESB


工作流的生命周期
1) 定义 :
    工作流生命周期总是从流程定义开始, 一般由业务人员进行,然后交给开发人员加工转换为计算机可以识别的流程定义
2) 发布:
    由开发人员打包各种资源,然后在系统管理(平台) 中发布流程定义 .在具体的流程引擎中包括流程定义文件
    (bpmn20.xml结尾) 自定义表单,任务监听类
3) 执行
    具体的流程引擎( Activiit) 按照事先定义好的流程处理路线以任务驱动的方式执行业务流程
4) 监控
    此阶段依赖执行阶段,业务人员在办理任务的同时收集每个任务(Task)的结果 ,然后根据结果做出相应处理
5) 优化
    在此阶段,一个完整的流程已经结束, 或许能满足业务需求,或许需要优化 或者重新设计,
    改进完成之后 在此 重1开始

Activiti 一些 包 具体都是做什么的
    org.activiit.engine  包括8大Servcie  异常类定义, 流程引擎 流程引擎配置类 ,还有一些 运行时异常类
    org.activiit.engine.delegate  该包定义了处理流程的行为,监听事件的规范,在实际应用中可以在流程定义中配置
    实现了监听接口的类处理业务逻辑, eg:在流程结束时自动归档,
    Activiit使用的是 Observer 监听器者模式,  在流程运行过程中(任务完成)引擎会遍历注册的监听器 依次调用
    org.activiit.engine.form 内置表单场景下,  forservcie有关, 我们不使用
    org.activiit.engine.history   流程历史
        .identity  管理和身份认证
    management  流程引擎的管理功能, 通过调用接口 ManagementService 监控引擎状态,任务调度,DB读取
    query: 该包没有具体的功能, 定义了查询的公有特性,  XXXQuery接口 都继承Query
    repository:包含了针对流程资源的管理和查询,
    runtime  runtimeServicie
    task taskServcie相关
    test  针对快速创建测试用例提供父类以及注解


对整个流程的信息的设置
    id :  建议纯英文标识
    name  流程名称 可以是任意字符
    namespace : 命名空间 一般使用 公司名或者组织域名+项目名称
            company/project/module 这样读者在实际项目中可以使用此属性来归类流程
    Document 简短描述

    关于SequenceFlow
        condition:
            没有设置condition的就是标准顺序流
            设置了 condition的就是条件顺序流
    条件顺序流的XML  是在 顺序流中添加了条件表达式标签 conditionExpression
    并且在             conditionExpression 中设置 JUEL表达式 用于计算逻辑值

用户任务
    pripoty 优先级   0~100

脚本任务:
    Activiti 支持 Groovy ,JavaScript ,JUEL
    脚本任务的代码需要符合 JSR-223

 <scriptTask id="scripttask1" name="Script Task" scriptFormat="groovy" activiti:autoStoreVariables="false" >
      <script>11111</script>
    </scriptTask>

scriptFormat  用来指定 JSR-22规范的脚本语言的类型

servcieTask
允许定义了一个实现指定接口的Java类 或者执行一个表达式, 还可以像脚本任务一样把结果保存到一个变量中

这个Java类需要实现 JavaDelegate  , ActivityBehavior 中的一个接口
并且在指定一个Java类的同时 还可以配置 执行Service时传入的变量, 这样在执行Java类的时候可以读取预先设置的变量值

<serviceTask id="servicetask1" name="Service Task" activiti:class="com.sun.prism.j2d.J2DFontFactory"></serviceTask>


<serviceTask id="servicetask1" name="Service Task" activiti:expression="#{hello.back()}"></serviceTask>
可以使用JUEL定义需要执行的任务内容, eg: 计算公式,调用bean对象的() 并且在执行任务的时候可以使用流程变量作为参数
Bena实例除了new 创建之外 还可以使用Spring代理

其中hello 作为一个流程变量存在,  和Activiti class 一样需要实现 JavaDelegate 或者 ActivityBehavior接口  另外 实现了序列化接口

<serviceTask id="servicetask1" name="Service Task" activiti:delegateExpression="${helloService}"></serviceTask>
功能和 activiti:class类似,而且需要实现 JavaDelegate 或者ActivityBehavior 接口
不过这里不是指定一个具体的实现类,而是在运行时动态设置,  和 expression方式类似 bean可以new 也可以使用spring代理

执行任务时,引擎会从变量中查询名称为 helloService的bean对象, 然后调用实现接口的()

<serviceTask id="servicetask1" name="Service Task" activiti:expression="#{hello.back()}" activiti:resultVariableName="javae"></serviceTask>
此属性仅仅适用于 expression类型的JavaServcie 可以把一个表达式的执行结果保存到 resultVariable指定变量名称中
eg: 把 helloService.back() 执行的结果 保存到变量 backDate中



webServcie任务  不用学了, 整起来麻烦

邮件任务:
    邮件信息可以通过变量传递,
    邮件 是 serviceTask 由Activiti添加了扩展属性

  Camel 一般用不到  也是Activiti 在ServiceTask上扩展的  不属于BPMN2.0规范
  Mule 一般用不到   在 SendTask上扩展的,  可以直接在流程中通过添加task的方式调用Muel 处理业务逻辑
  手动任务  不做任何事情, 仅仅用来定义BPM不能完成的任务,   流程引擎无需关心如何处理它,因为根本不需要处理
  Activiti把手动任务当做一个空任务来处理, 当到达此任务时 由引擎自动完成并转向到下一个任务

接收任务
    在任务创建开始之后等待消息的到来,知道被触发才会完成任务
    Activiit把接收任务作为一个Java类型的接收任务 仅能通过 RuntimeServcie.signal 发送信号
    类似线程的等待和恢复执行,只不过线程是在内存中操作,而接收任务则是把状态保存在DB中
    在调用 Activiti的 API 触发流程的接收任务之后, 引擎把当前流程由等待状态恢复为可执行状态

Shell 任务
    允许在流程运行过程中执行本地OS中的脚本 命令, 是Activiti基于 ServcieTask扩展的 ,  activiti:type="shell"



多实例任务
用户任务
脚本任务
JavaSerice
wEBServcie
业务规则
邮件
手动
接收
子流程(嵌入式)
子流程(调用活动

网关和事件不支持多实例
在BPMN2.0规范中定义 多实例的几个属性变量, 可以通过execution.getVariable获取变量


网关
    排他网关
        排他网关需要和条件顺序流使用, 一个排他网关可以连接 多个条件顺序流 而费 2个
        每个条件顺序流设置一个条件在运行时由引擎计算并且根据结果是否为treu决定执行与否

        如果多个为true 只会执行bpmn文件中最先定义的一个
        如果没有为true  判断是否有 default Flow  (也即网关默认的出线) 如果没有设置默认出线 则报错


    并行网关
    拆分:  并行执行所有的输出顺序流,并且为每一条顺序流创建一个并行执行线路
    合并, 所有从并行网关拆分并执行完成的线路均再次等候,知道所有的线路都执行完毕才会继续向下执行

    注意: 并行网关不会计算线路上设置的条件, 如果设置了, 则会直接忽略
    并行网关允许在 线路上 嵌套并行网关,  只需要保证最后一个有 点合并拆分的线路即可

    包容网关
        结合了排他网关和并行网关的特性, 允许在每条线路上设置条件, 并行网关可以同时执行多条线路
        包容网关既可以同时执行多条线路,又允许在网关上设置条件
      拆分:  计算每条线路上的表达式,当表达式计算结果为true时, 创建一个并行执行线路并继续执行
        合并, 所有从并行网关拆分并执行完成的线路均再次等候,知道所有的线路都执行完毕才会继续向下执行

    事件网关
        为中间捕获事件设置的


子流程和调用活动
    实际企业应用中,业务流程往往比较复杂,仔细分析之后一般可以将其划分为多个不同的阶段,可以把这些
    阶段规划为一个子流程作为主流程的一部分, 子流程正是这样

    还有一些通用的流程, 在业务架构中做为一个通用的模块 eg:不同的业务根据财务流程的规范传入指定的参数
    就可以使用付款流程

    调用活动的特点和子流程类似, 但是子流程嵌套在主流程中
    所以调用 活动既包含了 子流程的特性 又保持了通用

对子流程BPMN2.0规范做了一些限制
1)只能且仅能包含一个空启动事件
2)至少要有一个结束事件(每个流程 都要有始有终)
3) 在子流程中顺序流不能直接设置输出流程到子流程之外的活动上,如果需要,可以通过边界事件代替
    BPMN2.0规范允许子流程不包含启动 结束事件,但是Activiti不支持,


    子流程和调用活动的区别
表现形式        直接嵌入在主流程中使用subprocess..      作为一个普通的模型,定义外部流程的ID
模型约束        启动事件只能使用空启动事件           无任何限制,被调用的外部流程本身就是一个完整的流程
流程变量,      子流程共享主流程所有变量                 需要指定 输入,输出变量


关于执行监听器和任务监听器
    执行监听器允许在执行流程过程中执行Java代码(实现了监听器接口) 或表达式

    3种方式 class expression  delegateExpression  只能用其中一种

    class 方式   配置全类名
    express    eg:    ${pojo.method(execution.eventName) }
        这里的pojo是一个Bena的名称(可以用Spring代理) 还可以在expression中通过计算一个表达式配置监听器的名称
    delegateExpression:
        class方式必须是全类名, 而有些情况下需要根据业务的不同动态指定一个接口实现
        允许指定一个实现了监听接口类的 name
        eg:   ${executionListenerBean}     executionListenerBean 是一个Bean对象的名称

    任务监听器:
        create  在任务被创建并且所有的任务属性设置完成之后触发
        assignment: 在任务被分配给某个办理人触发, 有一点需要注意
            assignment总是在create之前触发, 因为任务的办理人是一个属性
            而create需要逐一处理任务的办理人, 候选人 ,候选组 等属性
        complete 在配置了监听器的上一个任务完成时触发, 也就是在运行时任务数据被删除之前(Activiti分为运行和历史)




关于zip方式部署
    一个流程定义会对应一个图片资源, 图片可以由引擎自动生成 或者与流程定义一起部署(压缩包方式,这样引擎就不会自动生成图片资源
    而是使用部署包中的图片资源
    是否生成扸分为2种情况
    如果仅仅部署了 扩展名为bpmn或者bpmn20.xml文件会自动生成图片
    如果部署的是一个压缩包,这个压缩包中可能有很多个文件,甚至多个流程定义文件
    若压缩包中不包含和流程定义同名的图片文件,则引擎同样会自动生成图片文件


特性              引擎自动生成                  压缩包方式部署
图片元素的完整性     过长的文字被截取,坐标丢失(可以通过修改源码解决)     和部署时的图片一致
灵活性(添加其他附加文字,美化图片等)  不支持            和部署时的图片一致
部署方式            仅仅需要提供流程定义文件        必须提供流程定义文件和同名的图片文件,并且要打包成压缩文件


如果任务名称过长 则会用 ...代替,  可以通过修改源码方式解决


acitivit:initiator 作用 可以把启动流程实例的操作 以变量名称 applyUserId 保存到DB中
需要配合 identityServcie.setAuthenicated("userid");

如果需要获取设置的用户id 可以通过 Authentication.getAuthenticatedUserId();

关于设置 历史级别为full
    1) 在表单引擎中设置的变量 会存储2份
        以form filed 开头的是 表单字段内容,
        其他以variable: 开头的是普通变量
        同样的一个变量在 ACT_HI_DETAIL中 出现了2次 为什么?
        因为在保存表单字段的同时会复制一份经过类型转换的值,
        并且以字段的ID 为变量名,保存到DB中,  前提是历史级别为full
        以date变量为例
            以form field: 开头的变量 startDate 值为 2012-11-26(字符型)
            以variable 的 是 startDate值为 一个 标准的 CST日期

    技巧:  当assignee为空时 显示签收, 否则显示 办理,



在流程定义中几乎所有的属性都可以使用变量方式定义,这样就可以灵活地设置
流程定义文件中出现的判断的条件 或者调用一个bean的()  都称之为表达式
表达式的解析由JUEL 根据UEL 规范实现, 之后Activiti又对JUEL进行扩展以满足更多的需求

${myVar}  获取变量名称为myVar的值
${myVar.name}  从变量myVar中读取 name属性
${serviceBean.confirm()}  执行变量名称为ServcieBean的  confirm()
${serviceBean.confirm('java')}  执行变量名称为ServcieBean的  confirm()
java 也可以使用流程变量代替,如果在变量中包含一个名称为name的变量 就可以动态设置方法的参数
eg: ${serviceBean.confirm(name)}
${serviceBean.confirm(name,execution)}  执行变量名称为ServcieBean的  confirm()
    并且传入 name的变量作为第一个参数,   引擎内置的execution作为第2个参数


execution
    此变量在运行阶段总是可以调用,  对应接口 DelegateExecution   可以获取流程实例的变量
    eg: 流程实例id, businessKey 当前节点节点, 另外还可以直接获取  8大service接口
    如果在流程定义中添加了执行监听器(ExecutionListener接口) 或者为某个活动添加了 Delegate(实现JavaDelegate接口)
    那么接口将提供一个 DelegateExecution 作为参数

task
    相对于execution来说 task作用域比较小,   task(DelegateTasl) 仅仅支持用户任务  而且限定为 expression类型
    所以通过此变量可以设置或者读取任务相关的变量, 设置任务办理人或者候选人

authenticatedUserId
    启动流程实例之前调用 IdentityService的 setAuthenticatedUserId() 才会由引擎提供,
    执行 ${authenticatedUserId}

    在Activiit中 所有表达式中出现的变量 都需要实现 序列化接口
    上述3个内置变量 仅仅能通过表达式获取,不能通过RuntimeService 或者 TaskService.getVariable获取


    我们也可以为 监听器 注入字段
    eg:
        content      Hello, ${name}
        task   ${task}
        监听器的实现类中 必须有同名并且类型为 Expression的字段,可以选择性提供字段的setter()
        如果没有 setter()  引擎会通过反射机制设置变量(也即设置访问权限为private)

        字段的值 可以是一个纯文本 ,也可以是表达式  并且可以混用
        如果字段仅仅设置为了纯文本,那么在XML中 将使用 activiti:string 代替 activiti:expression
        但是在监听器的类中还是需要使用Expression作为字段的类型

        private Expression content;
        private Expression  task;

        可以通过 在监听器的 notify() 中 调用 getEventName() 获取触发监听器的事件类型
        DelegateExecution 事件取值范围是 start end
        DelegateExecution 的事件取值范围是  create  assignment  complete


修改 task相关信息
Task task =taskServcie.createTaskQuery.singleResult();
task.setdueDate(new Date());
task.saveTask();


关于任务的相关人员
拥有人(owner)   办理人(assignee)   以及其他类别

assignee :   任务办理人 不会向ACT_RU_IDENTITYLINK中插入数据 和Task.setAssignee()  实际上就是调用的这个()
owner:   任务拥有人,  与assignee一样  不会向ACT_RU_IDENTITYLINK中插入数据  仅仅调用 Task.setOwner()
candidate: 表示任务的候选(人或组) 根据表中的两个字段(USER_ID, GROUP_ID) 来判断是否是候选人还是候选组
starter  启动人  如果在启动流程时设置了认证用户,则会向表ACT_RU_IDENTITYLINK表中插入一条数据表示流程启动人
particpant  在添加 候选人,候选组, 或者非引擎支持的关系类型时 会以 流程实例id作为标志(仅设置PROC_INST_ID)
不设置TASK_ID_  插入到 ACT_RU_IDENTITYLINK表中 方便根据实例查询参与人数据


taskInvolvedUser() 查询受邀rnewu
参与人一般不能签收任务,所以可以在签收时判断当前人是否在候选人,候选组范围之内,否则不执行签收动作

子任务:
    通过API创建一个任务 并设置父任务ID  最后保存即可,当然可以同时设置该任务的其他属性(可以是Task对象支持的所有属性)
    Task newTask  taskService.newTask();
    newTask.setParentId(parentTaskId); //设置父任务id 建立上下级关系
    .setOwner
    setAssignee
    setName
    .setDesc()
    taskService.saveTask();

    //读取子任务
    historyServcie.createHistoricTaskInstanceQuery().taskParentTask(taskId).list();
    //读取父任务
    historyServcie.createHistoricTaskInstanceQuery().taskId(task.getParentId()).list();

    因为添加的子任务没有设置流程实例id 所以对于子任务而言就不能正常添加读取意见列表了

    而且 如果要查询Commment  而对于子任务没有流程实例得情况 需要使用下面的代码查询Comment





























































































































































































































































































































